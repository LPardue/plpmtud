<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0678.xml">
<!ENTITY RFC768 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC792 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC1122 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1123 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1812 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1812.xml">
<!ENTITY RFC1191 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1981 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2475 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2475.xml">
<!ENTITY RFC2553 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2553.xml">
<!ENTITY RFC2923 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2923.xml">
<!ENTITY RFC3168 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3260 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3260.xml">
<!ENTITY RFC3395 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3395.xml">
<!ENTITY RFC3396 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3396.xml">
<!ENTITY RFC3493 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3678.xml">
<!ENTITY RFC3828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC4340 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4820 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4828.xml">
<!ENTITY RFC4890 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4890.xml">
<!ENTITY RFC4960 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5082 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5082.xml">
<!ENTITY RFC5097 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC6679 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6679.xml">
<!ENTITY RFC6935 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC6968 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6968.xml">
<!ENTITY RFC6633 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6633.xml">
<!ENTITY RFC8085 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml">
<!ENTITY RFC8201 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml">
<!ENTITY RFC8261 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8261.xml">
<!ENTITY I-D.ietf-tsvwg-udp-options SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-udp-options-04.xml">
<!ENTITY I-D.ietf-quic-transport SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-quic-transport-13.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-tsvwg-datagram-plpmtud-04tobe"
     ipr="trust200902" updates="4821">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
                 or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
     full title is longer than 39 characters -->

    <title abbrev="DPLPMTUD ">Packetization Layer Path MTU Discovery for
    Datagram Transports</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3U</code>

          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Tom Jones" initials="T" surname="Jones">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3U</code>

          <country>UK</country>
        </postal>

        <email>tom@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Michael Tuexen" initials="M" surname="Tuexen">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Stein fart</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>

    <author fullname="Irene Ruengeler" initials="I" surname="Ruengeler">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Stein fart</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>i.ruengeler@fh-muenster.de</email>
      </address>
    </author>

    <date day="02" month="July" year="2018" />

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>UDP SCTP Transport PMTUD PLPMTUD</keyword>

    <abstract>
      <t>This document describes a robust method for Path MTU Discovery
      (PMTUD) for datagram Packetization layers. The document describes an
      extension to RFC 1191 and RFC 8201, which specifies ICMP-based Path MTU
      Discovery for IPv4 and IPv6. The method allows a Packetization Layer
      (PL), or a datagram application that uses a PL, to discover whether a
      network path can support the current size of datagram. This can be used
      to detect and reduce the message size when a sender encounters a network
      black hole (where packets are discarded, and no ICMP message is
      received). The method can also probe a network path with progressively
      larger packets to find whether the maximum packet size can be increased.
      This allows a sender to determine an appropriate packet size, providing
      functionally for datagram transports that is equivalent to the
      Packetization layer PMTUD specification for TCP, specified in
      RFC4821.</t>

      <t>The document also provides implementation notes for incorporating
      Datagram PMTUD into IETF Datagram transports or applications that use
      transports.</t>

      <t>When published, this specification updates RFC4821.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The IETF has specified datagram transport using UDP, SCTP, and DCCP,
      as well as protocols layered on top of these transports (e.g., SCTP/UDP,
      DCCP/UDP) and directly over the IP network layer. This document
      describes a robust method for Path MTU Discovery (PMTUD) that may be
      used with these transport protocols (or the applications that use their
      transport service) to discover an appropriate size of packet to use
      across an Internet path.</t>

      <section anchor="Classic-PMTUD" title="Classical Path MTU Discovery">
        <t>Classical Path Maximum Transmission Unit Discovery (PMTUD) can be
        used with any transport that is able to process ICMP Packet Too Big
        (PTB) messages (e.g., <xref target="RFC1191"></xref> and <xref
        target="RFC8201"></xref>). The term PTB message is applied to both
        IPv4 ICMP Unreachable messages (type 3) that carry the error
        Fragmentation Needed (Type 3, Code 4) and ICMPv6 packet too big
        messages (Type 2). When a sender receives a PTB message, it reduces
        the effective MTU to the value reported as the Link MTU in the PTB
        message, and a method that from time-to-time increases the packet size
        in attempt to discover an increase in the supported PMTU. The packets
        sent with a size larger than the current effective PMTU are known as
        probe packets.</t>

        <t>Packets not intended as probe packets are either fragmented to the
        current effective PMTU, or the attempt to send fails with an error
        code. Applications are sometimes provided with a primitive to let them
        read the maximum packet size, derived from the current effective
        PMTU.</t>

        <t>Classical PMTUD is subject to protocol failures. One failure arises
        when traffic using a packet size larger than the actual PMTU is
        black holed (all datagrams sent with this size, or larger, are
        silently discarded without the sender receiving ICMP PTB messages).
        This could arise when the PTB messages are not delivered back to the
        sender for some reason <xref target="RFC2923"></xref>). For example,
        ICMP messages are increasingly filtered by middleboxes (including
        firewalls) <xref target="RFC4890"></xref>. A stateful firewall could
        be configured with a policy to block incoming ICMP messages, which
        would prevent reception of PTB messages to endpoints behind this
        firewall. Other examples include cases where PTB messages are not
        correctly processed/generated by tunnel endpoints.</t>

        <t>Another failure could result if a node that is not on the network
        path sends a PTB message that attempts to force the sender to change
        the effective PMTU <xref target="RFC8201"></xref>. A sender can
        protect itself from reacting to such messages by utilising the quoted
        packet within a PTB message payload to validate that the received PTB
        message was generated in response to a packet that had actually
        originated from the sender. However, there are situations where a
        sender would be unable to provide this validation.</t>

        <t>Examples where validation of the PTB message is not possible
        include:</t>

        <t><list style="symbols">
            <t>When the router issuing the ICMP message is acting on a
            tunneled packet, the ICMP message will be directed to the tunnel
            endpoint. This tunnel endpoint is responsible for forwardiung the
            ICMP message and also processing the quoted packet within the
            payload field to remove the effect of the tunnel, and return a
            correctly fromatted ICMP message to the sender. Failure to do this
            results in black-holing.</t>

            <t>When a router issuing the ICMP message implements RFC792 <xref
            target="RFC0792"></xref>, it is only required the to include the
            first 64 bits of the IP payload of the packet within the quoted
            payload.This may be insufficient to perfom the tunnel processing
            described in the previous bullet. Even if the decapsulated message
            is processed by the tunnel endpoint, there could be insufficient
            bytes remaining for the sender to interpret the quoted transport
            information. RFC1812 <xref target="RFC1812"></xref> requires
            routers to return the full packet if possible, often the case for
            IPv4 when used the path includes tunnels; or where the packet has
            been encapsulated/tunneled over an encrypted transport and it is
            not possible to determine the original transport header ).</t>

            <t>Even when the PTB message includes sufficient bytes of the
            quoted packet, the network layer could lack sufficient context to
            validate the message, because this depends on information about
            the active transport flows at an endpoint node (e.g., the
            socket/address pairs being used, and other protocol header
            information).</t>
          </list></t>
      </section>

      <section title="Packetization Layer Path MTU Discovery">
        <t>The term Packetization Layer (PL) has been introduced to describe
        the layer that is responsible for placing data blocks into the payload
        of IP packets and selecting an appropriate Maximum Packet Size (MPS).
        This function is often performed by a transport protocol, but can also
        be performed by other encapsulation methods working above the
        transport.</t>

        <t>In contrast to PMTUD, Packetization Layer Path MTU Discovery
        (PLPMTUD) <xref target="RFC4821"></xref> does not rely upon reception
        and validation of PTB messages. It is therefore more robust than
        Classical PMTUD. This has become the recommended approach for
        implementing PMTU discovery with TCP.</t>

        <t>It uses a general strategy where the PL sends probe packet to
        search for the largest size of unfragmented datagram that can be sent
        over a path. The probe packets are sent with a progressively larger
        packet size. If a probe packet is successfully delivered (as
        determined by the PL), then the PLPMTU is raised to the size of the
        successful probe. If no response is received to a probe packet, the
        method reduces the probe size. This PLPMTU is used to set the
        application MPS.</t>

        <t>PLPMTUD introduces flexibility in the implementation of PMTU
        discovery. At one extreme, it can be configured to only perform PTB
        black hole detection and recovery to increase the robustness of
        Classical PMTUD, or at the other extreme, all PTB processing can be
        disabled and PLPMTUD can completely replace Classical PMTUD.</t>

        <t>PLPMTUD can also include additional consistency checks without
        increasing the risk of increased black-holing. For instance,the
        information available at the PL, or higher layers, makes PTB
        validation more straight forward.</t>
      </section>

      <section title="Path MTU Discovery for Datagram Services">
        <t><xref target="Spec"></xref> of this document presents a set of
        algorithms for datagram protocols to discover the largest size of
        unfragmented datagram that can be sent over a path. The method
        described relies on features of the PL described in <xref
        target="Requirements"></xref> and applies to transport protocols
        operating over IPv4 and IPv6. It does not require cooperation from the
        lower layers, although it can utilise ICMP PTB messages when these
        received messages are made available to the PL.</t>

        <t>The UDP Usage Guidelines <xref target="RFC8085"></xref> state "an
        application SHOULD either use the Path MTU information provided by the
        IP layer or implement Path MTU Discovery (PMTUD)", but does not
        provide a mechanism for discovering the largest size of unfragmented
        datagram than can be used on a path. Prior to this document, PLPMTUD
        had not been specified for UDP.</t>

        <t>Section 10.2 of <xref target="RFC4821"></xref> recommends a PLPMTUD
        probing method for the Stream Control Transport Protocol (SCTP). SCTP
        utilises heartbeat messages as probe packets, but RFC4821 does not
        provide a complete specification. This document provides the details
        to complete that specification.</t>

        <t>The Datagram Congestion Control Protocol (DCCP) <xref
        target="RFC4340"></xref> requires implementations to support Classical
        PMTUD and states that a DCCP sender "MUST maintain the MPS allowed for
        each active DCCP session". It also defines the current congestion
        control MPS (CCMPS) supported by a path. This recommends use of PMTUD,
        and suggests use of control packets (DCCP-Sync) as path probe packets,
        because they do not risk application data loss. The method defined in
        this specification could be used with DCCP.</t>

        <t><xref target="protocol_specific_methods"></xref> specifies the
        method for a set of transports, and provides information to enables
        the implementation of PLPMTUD with other datagram transports and
        applications that use datagram transports.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      <t>Other terminology is directly copied from <xref
      target="RFC4821"></xref>, and the definitions in <xref
      target="RFC1122"></xref>.</t>

      <t><list style="hanging">
	  <t hangText="Black Holed:">When the sender is unaware that packets
	  are not delivered to the destination endpoint (e.g., when the sender
	  transmits packets of a particular size with a previously known
	  effective PMTU (also refered to as the PLPMTU), but is not made aware
	  of a change to the path that resulted in a smaller PLPMTU by ICMP
	  messages).</t>

          <t hangText="Classical Path MTU Discovery:">Classical PMTUD is a
          process described in <xref target="RFC1191"></xref> and <xref
          target="RFC8201"></xref>, in which nodes rely on PTB messages to
          learn the largest size of unfragmented datagram than can be used
          across a path.</t>

          <t hangText="Datagram:">A datagram is a transport-layer protocol
          data unit, transmitted in the payload of an IP packet.</t>

          <t hangText="Effective PMTU:">The current estimated value for PMTU
          that is used by a PMTUD. This is equivalent to the PLPMTU derived by
          PLPMTUD.</t>

          <t hangText="EMTU_S:">The Effective MTU for sending (EMTU_S) is
          defined in <xref target="RFC1122"></xref> as "the maximum IP
          datagram size that may be sent, for a particular combination of IP
          source and destination addresses...".</t>

          <t hangText="EMTU_R:">The Effective MTU for receiving (EMTU_R) is
          designated in <xref target="RFC1122"></xref> as the largest datagram
          size that can be reassembled by EMTU_R ("Effective MTU to
          receive").</t>

          <t hangText="Link:">A communication facility or medium over which
          nodes can communicate at the link layer, i.e., a layer below the IP
          layer. Examples are Ethernet LANs and Internet (or higher) layer and
          tunnels.</t>

          <t hangText="Link MTU:">The Maximum Transmission Unit (MTU) is the
          size in bytes of the largest IP packet, including the IP header and
          payload, that can be transmitted over a link. Note that this could
          more properly be called the IP MTU, to be consistent with how other
          standards organizations use the acronym MT. This includes the IP
          header, but excludes link layer headers and other framing that is
          not part of IP or the IP payload. Other standards organizations
          generally define link MTU to include the link layer headers.</t>

          <t hangText="MPS:">The Maximum Packet Size (MPS) is the largest size
          of application data block that can be sent unfragmented across a
          path. In DPLPMTUD this quantity is derived from PLPMTU by taking
          into consideration the size of the application and lower protocol
          layer headers.</t>

          <t hangText="Packet:">An IP header plus the IP payload.</t>

          <t hangText="Packetization Layer (PL):">The layer of the network
          stack that places data into packets and performs transport protocol
          functions.</t>

          <t hangText="Path:">The set of link and routers traversed by a
          packet between a source node and a destination node by a particular
          flow.</t>

          <t hangText="Path MTU (PMTU):">The minimum of the Link MTU of all
          the links forming a path between a source node and a destination
          node.</t>

          <t hangText="PLPMTU:">The estimate of the actual PMTU provided by
          the DPLPMTUD algorithm.</t>

          <t hangText="PLPMTUD:">Packetization Layer Path MTU Discovery, the
          method described in this document for datagram PLs, which is an
          extension to Classical PMTU Discovery.</t>

          <t hangText="Probe packet:">A datagram sent with a purposely chosen
          size (typically larger than the current PLPMTU) to detect if packets
          of this size can be successfully sent end-to-end across the network
          path.</t>
        </list></t>
    </section>

    <section anchor="Requirements"
             title="Features Required to Provide Datagram PLPMTUD">
      <t>TCP PLPMTUD has been defined using standard TCP protocol mechanisms.
      All of the requirements in <xref target="RFC4821"></xref> also apply to
      use of the technique with a datagram PL. Unlike TCP, some datagram PLs
      require additional mechanisms to implement PLPMTUD.</t>

      <t>There are eight requirements for performing the datagram PLPMTUD
      method described in this specification: <list style="numbers">
          <t>PMTU parameters: A DPLPMTUD sender is RECOMMENDED to provide
          information about the maximum size of packet that can be transmitted
          by the sender on the local link (the local Link MTU). It MAY utilize
          similar information about the receiver when this is supplied (note
          this could be less than EMTU_R). This avoids implementations trying
          to send probe packets that can not be transmited by the local link.
          Too high a value may reduce the efficiency of the search algorithm.
          Some applications also have a maximum transport protocol data unit
          (PDU) size, in which case there is no benefit from probing for a
          size larger than this (unless a transport allows multiplexing
          multiple applications PDUs into the same datagram).</t>

          <t>PLPMTU: A datagram application MUST be able to choose the size of
          datagrams sent to the network, up to the PLPMTU, or a smaller value
          (such as the MPS) derived from this. This value is managed by the
          DPLPMTUD method. The PLPMTU (specified as the effective PMTU in
          Section 1 of <xref target="RFC1191"></xref>) is equivalent to the
          EMTU_S (specified in <xref target="RFC1122"></xref>).</t>

          <t>Probe packets: On request, a DPLPMTUD sender is REQUIRED to be
          able to transmit a packet larger than the PLMPMTU. This can be uses
          to send a probe packet. In IPv4, a probe packet MUST be sent with
          the Don't Fragment (DF) bit set in the IP header, and without
          network layer endpoint fragmentation. In IPv6, a probe packet is
          always sent without source fragmentation (as specified in section
          5.4 of <xref target="RFC8201"></xref>).</t>

          <t>Processing PTB messages: A DPLPMTUD sender MAY optionally utilize
          PTB messages received from the network layer to help identify when a
          path does not support the current size of packet probe. Any received
          PTB message MUST be validated before it is used to update the PLPMTU
          discovery information <xref target="RFC8201"></xref>. This
          validation confirms that the PTB message was sent in response to a
          packet originating by the sender, and needs to be performed before
          the PLPMTU discovery method reacts to the PTB message. When the
          router link MTU is indicated in the PTB message this MAY be used by
          DPLPMTUD to reduce the probe size but MUST NOT be used to increase
          the PLPMTU (<xref target="RFC8201"></xref>). This validation SHOULD
          utilise information that can not be simply determined by an off-path
          attacker, for example, by checking the value of a protocol header
          field known only to the two PL endpoints. (Some datagram
          applications use well-known source and destination ports and
          therefore this check needs to rely on other information.)</t>

          <t>Reception feedback: The destination PL endpoint is REQUIRED to
          provide a feedback method that indicates to the DPLPMTUD sender when
          a probe packet has been received by the destination PL endpoint. The
          mechanism needs to be robut to the possibility that packets could be
          significantly delayed along a network path. The local PL endpoint at
          the sending node is REQUIRED to pass this feedback to the
          sender-side DPLPMTUD method.</t>

          <t anchor="CC">Probing and congestion control: The isolated loss of
          a probe packet SHOULD NOT be treated as an indication of congestion
          and its loss SHOULD NOT directly trigger a congestion control
          reaction <xref target="RFC4821"></xref>.</t>

          <t>Probe loss recovery: If the data block carried by a probe packet
          needs to be sent reliably, the PL (or layers above) MUST arrange
          retransmission/repair of any resulting loss. This method MUST be
          robust in the case where probe packets are lost due to other reasons
          (including link transmission error, congestion). The DPLPMTUD method
          treats isolated loss of a probe packet (with or without an PTB
          message) as a potential indication of a PMTU limit on the path, but
          not as an indictaion of congestion <xref target="CC"></xref>.</t>

          <t>Shared PLPMTU state: The PLPMTU value could also be stored with
          the corresponding entry in the destination cache and used by other
          PL instances. The specification of PLPMTUD <xref
          target="RFC4821"></xref> states: "If PLPMTUD updates the MTU for a
          particular path, all Packetization Layer sessions that share the
          path representation (as described in Section 5.2 of <xref
          target="RFC4821"></xref>) SHOULD be notified to make use of the new
          MTU and make the required congestion control adjustments". Such
          methods need to be robust to the wide variety of underlying network
          forwarding behaviours, PLPMTU adjustments based on shared PLPMTU
          values should be incorporated in the search algorithms. Section 5.2
          of <xref target="RFC8201"></xref> provides guidance on the caching
          of PMTU information and also the relation to IPv6 flow labels.</t>
	</list>In addition, the following principles are stated for design of a
	DPLPMTUD method:</t>

      <t><list style="symbols">
          <t>MPS: A method MUST signal appropriate MPS to the higher layer
          using the PL. This may change following a change to the path. The
          method SHOULD avoid forcing an application to use an arbitrary small
          MPS (PLPMTU) for transmission while the method is searching for the
          currently supported PLPMTU. Datagram PLs do not necessarily support
          fragmentation of PDUs larger than the PLPMTU. A reduced MPS can
          adversely impact the performance of a datagram application.</t>

          <t>Path validation: A method MUST be robust to path changes that
          could have occurred since the path characteristics were last
          confirmed, and to the possibility of inconsistent path information
          being received.</t>

          <t>Datagram reordering: A method MUST be robust to the possibility
          that a flow encounters reordering, or has the traffic (including
          probe packets) is divided over more than one network path.</t>

          <t>When to probe: A method SHOULD determine whether the path
          capacity has increased since it last measured the path. This
          determines when the path should again be probed.</t>
        </list></t>
    </section>

    <section title="DPLPMTUD Mechanisms">
      <t>This section lists the protocol mechanisms used in this
      specification.</t>

      <section anchor="Probe" title="PLPMTU Probe Packets">
        <t>The DPLPMTUD method relies upon the PL sender being able to
        generate probe packets with a specific size. TCP is able to generate
        these probe packets by choosing to appropriately segment data being
        sent <xref target="RFC4821"></xref>.</t>

        <t>In contrast, a datagram PL that needs to construct a probe packet
        has to either request an application to send a data block that is
        larger than that generated by an application, or to utilise padding
        functions to extend a datagram beyond the size of the application data
        block. Protocols that permit exchange of control messages (without an
        application data block) could alternatively prefer to generate a probe
        packet by extending a control message with padding data.</t>

        <t>When the method fails to validate the PLPMTU, it may be required to
        send a probe packet with a size less than the size of the data block
        generated by an application. In this case, the PL could provide a way
        to fragment a datagram at the PL, or could instead utilise a control
        packet with padding.</t>

        <t>A receiver needs to be able to distinguish an in-band data block
        from any added padding. This is needed to ensure that any added
        padding is not passed on to an application at the receiver.</t>

        <t>This results in three possible ways that a sender can create a
        probe packet listed in order of preference:<list style="hanging">
            <t hangText="Probing using padding data:">A probe packet that
            contains only control information together with any padding, which
            is needed to be inflated to the packet to the size required for
            the probe packet. Since these probe packets do not carry an
            application-supplied data block,they do not typically require
            retransmission, although they do still consume network capacity
            and incur endpoint processing.</t>

            <t hangText="Probing using application data and padding data:">A
            probe packet that contains a data block supplied by an application
            that is combined with padding to inflate the length of the
            datagram to the size required for the probe packet. If the
            application/transport needs protection from the loss of this probe
            packet, the application/transport may perform transport-layer
            retransmission/repair of the data block (e.g., by retransmission
            after loss is detected or by duplicating the data block in a
            datagram without the padding data).</t>

            <t hangText="Probing using application data:">A probe packet that
            contains a data block supplied by an application that matches the
            size required for the probe packet. This method requests the
            application to issue a data block of the desired probe size. If
            the application/transport needs protection from the loss of an
            unsuccessful probe packet, the application/transport needs then to
            perform transport-layer retransmission/repair of the data block
            (e.g., by retransmission after loss is detected).</t>
          </list>A PL that uses a probe packet carrying an application data
        block, could need to retransmit this application data block if the
        probe fails. This could need the PL to re-fragment the data block to a
        smaller packet size that is expected to traverse the end-to-end path
        (which could utilise network-layer or PL fragmentation when these are
        available).</t>

        <t>DPLPMTUD MAY choose to use only one of these methods to simplify the
        implementation.</t>
      </section>

      <section anchor="Valid" title="Confirmation of Probed Packet Size">
        <t>The PL needs a method to determine (confirm) when probe packets
        have been successfully received end-to-end across a network path.</t>

        <t>Transport protocols can include end-to-end methods that detect and
        report reception of specific datagrams that they send (e.g., DCCP and
        SCTP provide keep-alive/heartbeat features). When supported, this
        mechanism SHOULD also be used by DPLPMTUD to acknowledge reception of
        a probe packet.</t>

        <t>A PL that does not acknowledge data reception (e.g., UDP and
        UDP-Lite) is unable to detect when the packets that it sends are
        discarded because their size is greater than the actual PMTU. These
        PLs need to either rely on an application protocol to detect this
        loss, or make use of an additional transport method such as
        UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref>. In
        addition, they might need to send reachability probes (e.g.,
        periodically solicit a response from the destination) to determine
        whether the last successfully probed PLPMTU is still supported by the
        network path.</t>

        <t>Section <xref target="Spec"></xref> specifies this function for a
        set of IETF-specified protocols.</t>
      </section>

      <section title="Detection of Black Holes">
        <t>A PL sender needs to send probe packets of the size of the current
        PLPMTU to determine that this size still works.</t>

        <t>There are two ways a PL sender can detect that current PLPMTU is
        not sustained by the path: It can use the probing mechanism, or it can
        rely upon other mechansims provided by the PL to detect excessive loss
        and conclude that the loss may be a result of an invalid PMTU.</t>
      </section>

      <section anchor="mechanism-ptb" title="Response to PTB Messages">
	<t>This method requires the PL sender to validate the PTB message
	before use. PTB response depends on the the MTU carried in the PTB
	message, the state of the PLPMTUD state machine and the IP protocol
	being used.</t>

        <section anchor="PTB" title="Validation and Use of PTB Messages">
          <t>This section describes processing for both IPv4 ICMP Unreachable
          messages (type 3) and ICMPv6 packet too big messages.</t>

          <t>A PL that receives a PTB message from a router or middlebox, MUST
          validate the PTB message. The PL checks the protocol information in
          the quoted payload to validate the message originated from the
          sending node. The node also checks that the reported link MTU size
          is less than the size used by packet probes. PTB messages are
          discarded if they fail to pass these checks, or where there is
          insufficient ICMP payload to perform these checks. The checks are
          intended to provide protection from packets that originate from a
          node that is not on the network path or a node that attempts to
          report a larger link MTU than the current probe size.</t>

          <t>PTB messages that have been validated can be utilised by the
          DPLPMTUD algorithm. A method that utilises these PTB messages can
          improve the speed at the which the algorithm detects an appropriate
          PLPMTU compared to one that relies solely on probing.</t>
        </section>

        <section title="Use of PTB Information">
          <t>This section summarises the use of PTB information.</t>

          <t><list style="hanging">
              <t hangText="PTB MTU &lt; BASE_MTU"><list style="symbols">
                  <t>The simplest implementations ignore these messages and
                  the PLPMTU is not updated.</t>

                  <t>A method implementing robusness MAY move to the
                  PROBE_ERROR state for an IPv4 path where the MTU &lt;=
                  576B</t>

                  <t>A method implementing robusness MAY move to the
                  PROBE_ERROR state for an IPv6 path where the MTU &lt;=
                  1280B</t>
                </list></t>

              <t hangText="PTB MTU &lt; PLPMTU"><list style="symbols">
                  <t>The PLPMTU SHOULD be set to BASE_MTU.</t>

                  <t>The PLPMTU MAY use the PTB MTU to start a search
                  algorithm.</t>
                </list></t>

              <t hangText="PLPMTU &lt; PTB MTU &lt; PROBED_SIZE"><list style="symbols">
                  <t>This indicates that the PLPMTU is still valid, but the
                  last search PROBED_SIZE was not.</t>

                  <t>The PLPMTU is not updated.</t>

                  <t>The PTB MTU SHOULD be used as the next search point for
                  the search algorithm.</t>
                </list></t>
              <t hangText="Dealing with invalid PTB MTU sizes">
	      <list style="symbols">
                  <t>PTB messages must be validated before their MTU is
                  tested.</t>

		  <t> MTU values may however still invalid in validated
		  messages:<list style="symbols">
			  <t> PTB MTU &gt; PROBED_SIZE</t>
                  </list></t>
                </list></t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="Spec" title="Datagram Packetization Layer PMTUD">
      <t>This section specifies Datagram PLPMTUD (DPLPMTUD). This method can
      be introduced at various points in the IP protocol stack, to discover
      the PLPMTU so that the application can use an MPS appropriate to the
      current network path.</t>

      <t><figure anchor="fig-plpmtudimplement"
          title="Examples where DPLPMTUD can be implemented">
          <artwork><![CDATA[
  +----------------------+
  |         APP*         |
  +-+-------+----+---+---+
    |       |    |   |
+---+--+ +--+--+ | +-+---+
| QUIC*| |UDPO*| | |SCTP*|
+---+--+ +--+--+ | ++--+-+
    |       |    |  |  |
    +-------+-+  |  |  |
              |  |  |  |
             ++-+--++  |
             | UDP  |  |
             +---+--+  |
                 |     |
  +--------------+-----+-+
  |  Network Interface   |
  +----------------------+
]]></artwork>
        </figure></t>

      <t>The central idea of DPLPMTUD is probing by a sender. Probe packets
      are sent to find out the maximum size of user message that is completely
      transferred across the network path from the sender to the
      destination.</t>

      <section anchor="phases" title="DPLPMTUD Phases">
        <t>The Datagram PLPMTUD algorithm moves through several phases of
        operation</t>

        <t><list style="hanging">
            <t hangText="Path Validation"><list style="symbols">
                <t>Connectivity is confirmed</t>

                <t>BASE_MTU is confirmed</t>
              </list></t>

            <t hangText="Search"><list style="symbols">
                <t>Probing is performed to increase the PLPMTU.</t>
              </list></t>

            <t hangText="Search Complete"><list style="symbols">
                <t>DPLPMTUD has found an maximal PLPMTU that works on the
                path.</t>

                <t>DPLPMTUD will probe occasionally to confirm the PLPMTU</t>
              </list></t>

            <t hangText="Error"><list style="symbols">
                <t>Due to unconsistent or invalid network signals the
                DPLPMTUD algorithm is unable to progress.</t>
              </list></t>
          </list></t>

        <section anchor="phases-validation" title="Path Validation">
	  <t>Path validation happens in two stages, first connectivity to the
	  remote peer is confirmed, second the path must be proven to support
	  the BASE_MTU.</t>
	  
	  <t>Connectivity with a connected PL this stage is implicit and is
	  performed as part of the normal connection hand shake. In unconnected
	  PL's probing must be done to confirm that the remote peer is
	  reachable.</t>
	  
	  <t>The second stage of path validation is performed to confirm that
	  the path supports the BASE_MTU. Probing is performed to confirm that
	  BASE_MTU PROBED_SIZE packets can reach the remote peer using the
	  path. The PL may decide to perform connectivity checks with BASE_MTU
	  sized probes if they do not wish to support paths with MTU less than
	  BASE_MTU simplifying this phase into a single step.</t>
	  
	  <t>A PL MAY perform PTB Response while performing Path Validation.
	  Once path validation has completed the DPLPMTUD can advertise an MPS
	  to an upper layer. The MPS must be occasionally reverified by sending
	  probes at PROBED_SIZE to check the PLPMTU estimate is still
	  current.</t>
        </section>

        <section anchor="phases-search" title="Search">
	  <t>In the search phase the DPLPMTUD sends probes to test if the path
	  supports a larger MTU. Probes larger than the current PLPMTU
	  are sent. Search may be performed with one of the search algorithms
	  described in <xref target="phases-search-algorithms"></xref> or with
	  some other search algorithm. Probes sent in the search phase are
	  confirmed by positive acknowledgement in the PL. Black hole
	  detection must be performed for search probes. If a black hole is
	  detected for a PROBED_SIZE the probe is said to have failed. The
	  search algorithm should use probe failure to advance or terminate the
	  search. The DPLPMTUD may perform PTB Response while in the search
	  phase. The search algorihm may use PTB signals once verified to
	  advance or terminate the search.</t>

          <t>The DPLPMTUD method utilises probe packets to confirm that a
          packet of size PROBED_SIZE can traverse the network path. The
          PROBE_COUNT is initialised to zero when a probe packet is first sent
          with a particular size.</t>

          <t>A timer is used to trigger the generation of probe packets. The
          probe_timer is started each time a probe packet is sent to the
          destination and is cancelled when receipt of the probe packet is
          acknowledged. The PROBED_SIZE is confirmed, and this value is then
          assignmed to PLPMTU. The DPLPMTUD method may send subsequent probes
          of an increasing size. Increasing probes follow a search strategy as
          discussed in <xref target="Probe"></xref>.</t>

          <t>Each time the probe_timer expires, the PROBE_COUNT is
          incremented, the probe_timer is reinitialised, and a probe packet of
          the same size is retransmitted.</t>

          <t>The maximum number of retransmissions for a PROBED_SIZE is
          configured (MAX_PROBES). If the value of the PROBE_COUNT reaches
          MAX_PROBES, probing will stop and enters the PROBE_DONE start.</t>

          <section anchor="phases-search-algorithms" title="Search Algorithms">
            <t>XXX Suitable algorithms should be here XXX</t>
          </section>
        </section>

        <section anchor="phases-complete" title="Search Complete">
	  <t>In the search complete phase the PLPTMUD must occasionally
	  revalidate the PLPMTU estimate for the path. The PLPMTU is validated
	  by sending probes of PROBED_SIZE on the path and using black hole
	  detection to discover if the path still supports the PLPMTU. If a
	  black hole is detected the PLPMTU should be set to the BASE_MTU, an
	  appropriate MPS advertised and path validation must be performed. If
	  the path cannot be validated the DPLPMTUD moves into an error state.
	  </t>

	  <t>The error state is entered when there is conflicting or invalid
	  information coming from the path. The DPLPMTUD should remain in the
	  error state until a consistent view of the path can be discovered.
	  The minimum level for this is that the path supports BASE_MTU.</t>

          <t>When the PL sender completes probing for a larger PLPMTU, it
          enters the PROBE_DONE state. This starts the PMTU_RAISE_TIMER. While
          running, the PLPMTU remains at the value set in the last
          succesful probe packet.</t>

          <t>If the PL is designed in a way that is unable to validate
          reachability to the destination endpoint after probing has
          completed, the method uses a REACHABILITY_TIMER to periodically
          repeat a probe packet for the current PLPMTU size, while the
          PMTU_RAISE_TIMER is running. If the REACHABILITY_TIMER expires, the
          method exits the PROBE_DONE state. The done state is also exited
          when a validated PTB message is received.</t>

          <t>If the PMTU_RAISE_TIMER expires, the PL sender also exits the
          PROBE_DONE state, but in this case resumes probing from the size of
          the PLPMTU.</t>
        </section>
      </section>

      <section anchor="dplpmtud-components" title="DPLPMTUD Components">
      <section anchor="Timers" title="Timers">
        <t>The method in the previous subsections utilises three timers:<list
            style="hanging">
            <t hangText="PROBE_TIMER:">Configured to expire after a period
            longer than the maximum time to receive an acknowledgment to a
            probe packet. This value MUST be larger than 1 second, and SHOULD
            be larger than 15 seconds. Guidance on selection of the timer
            value are provide in section 3.1.1 of the UDP Usage Guidelines
            <xref target="RFC8085"></xref>.</t>

            <t hangText="">If the PL has an RTT estimate and timely
            acknowedgements the PROBE_TIMER can be derrived from the PL RTT
            estimate.</t>

            <t hangText="PMTU_RAISE_TIMER:">Configured to the period a sender
            ought to continue use the current PLPMTU, after which it
            re-commences probing for a higher PMTU. This timer has a period of
            600 secs, as recommended by PLPMTUD <xref
            target="RFC4821"></xref>.</t>

            <t hangText="REACHABILITY_TIMER:">Configured to the period a
            sender ought to wait before confirming the current PLPMTU is still
            supported. This is less than the PMTU_RAISE_TIMER and used to
            decrease the PLPMTU (e.g. when a black hole is encountered).</t>

            <t hangText="">DPLPMTUD ought to suspend reachability probes when
            no application data has been sent since the previous probe packet.
            Guidance on selection of the timer value are provide in section
            3.1.1 of the UDP Usage Guidelines<xref target="RFC8085"></xref>.
            DPLPMTUD ought to be suspended or only sent in conjuction with out
            traffic during periods of dormancy. This PLPMTU validation needs
            to be frequent enough when data is flowing that the sending PL
            does not black hole extensive amounts of traffic</t>
          </list></t>

        <t>An implementation could implement the various timers using a single
        timer process.</t>
      </section>

      <section title="Constants">
        <t>The following constants are defined:</t>

        <t><list style="hanging">
            <t hangText="MAX_PROBES:">The maximum value of the
            PROBE_ERROR_COUNTER. The default value of MAX_PROBES is 10.</t>

            <t hangText="MIN_PMTU:">The smallest allowed probe packet size.
            For IPv6, this value is 1280 bytes, as specified in <xref
            target="RFC2460"></xref>. For IPv4, the minimum value is 68 bytes.
            (An IPv4 routed is required to be able to forward a datagram of 68
            octets without further fragmentation. This is the combined size of
            an IPv4 header and the minimum fragment size of 8 octets.)</t>

            <t hangText="BASE_PMTU:">The BASE_PMTU is a considered a size that
            ought to work in most cases. The size is equal to or larger than
            the minimum permitted and smaller than the maximum allowed. In the
            case of IPv6, this value is 1280 bytes <xref
            target="RFC2460"></xref>. When using IPv4, a size of 1200 bytes is
            RECOMMENDED.</t>

            <t hangText="MAX_PMTU:">The MAX_PMTU is the largest size of PLPMTU
            that is probed. This has to be less than or equal to the minimum
            of the local MTU of the outgoing interface and the destination
            PLMTU for receiving. An application or PL may reduce this when it
            knows there is no need to send packets above a specific size.</t>
          </list></t>
      </section>

      <section title="Variables">
        <t>This method utilises a set of variables: <list style="hanging">
            <t hangText="PROBE_TIMER:">Configured to expire after a period
            longer than the maximum time to receive an acknowledgment to a
            probe packet. This value MUST be larger than 1 second, and SHOULD
            be larger than 15 seconds. Guidance on selection of the timer
            value are provide in section 3.1.1 of the UDP Usage Guidelines
            <xref target="RFC8085"></xref>.</t>

            <t hangText="">PL with RTT estimates may use values smaller than 1
            seconded derrived from their RTT estimate to speed up detection of
            connectivity issues on the path.</t>

            <t hangText="PROBED_SIZE:">The PROBED_SIZE is the size of the
            current probe packet. This is a tentative value for the PLPMTU,
            which is awaiting confirmation by an acknowledgment.</t>

            <t hangText="PROBE_COUNT:">This is a count of the number of
            unsuccessful probe packets that have been sent with size
            PROBED_SIZE. The value is initialised to zero when a particular
            size of PROBED_SIZE is first attempted.</t>

            <t hangText="PTB_SIZE:">The PTB_Size is value returned by a
            validated PTB message indicating the local MTU size of a router
            along the path.</t>
          </list></t>

	<t>The figure below illustrates the relationship between the packet
	size constants and variables, in this case when the DPLPMTUD algorithm
	performs path probing to increase the size of the PLPMTU. The MPS is
	less than the PLPMTU. A probe packet has been sent of size PROBED_SIZE.
	When this is acknowledged, the PLPMTU will be raised to PROBED_SIZE
	allowing the PROBED_SIZE to be increased towards the actual PMTU.</t>

        <t><figure anchor="fig-mps"
            title="Relationships between probe and packet sizes">
            <artwork><![CDATA[

     MIN_PMTU                                             PMTU_MAX
       <------------------------------------------------------>
                      |       |    |     |           |   
                      V       |    |     |           V
                  BASE_PMTU   V    |     V     Actual PMTU
                             MPS   |  PROBED_SIZE  
                                   V  
                                 PLPMTU
]]></artwork>
          </figure></t>
      </section>
      </section>

    <section title="DPLPMTUD Algorithms">
      <t>There are two core mechanisms to the PLPMTU discovery machine, they
      provide discovery of the supported PLPMTU on the path and detection of
      error conditions.</t>

      <t><list style="symbols">
          <t>Increasing the PLPMTU: Probing for a larger PLPMTU</t>

          <t>Black Hole Detection: Detecting when the current PLPMTU is no
          longer supported</t>
        </list>Two additional mechanisms are identified that can optimise the
      PLPMTU discovery machine improving behaviour when particular impairments
      are detected:</t>

      <t><list style="symbols">
          <t>Robustness to paths unable to sustain the base PLPMTU. Some paths
          may be unable to sustain packets of the base MTU size. These paths
          could allow fallback to a smaller than desired PLPMTU, rather than
          suffer connectiviuty failure.</t>

          <t>Resilliance to inconsistent path information. Sometimes the PL
          sender can detect inconsistent results to the PLPMTU probes that it
          sends. This can result in excessive fluctuation of the MPS. When
          this is detected, a PL sender can clamp the offered MPS to a smaller
          value to avoid unecessary black-holing of packets.</t>
        </list></t>

      <section anchor="Increase"
               title="Increasing the PLPMTU: Probing for a larger PLPMTU">
        <t>An implementation that only reduces the PLPMTU to a suitable size
        is sufficient to ensure reliable operation, but may be very
        inefficient when the actual PMTU changes or when the method (for
        whatever reason) makes a suboptimal choice for the PLPMTU.</t>

        <t>A full implementation of the DPLPMTUD method is RECOMMENDED to
        provide a way for the sending PL endpoint to detect when the PLPMTU is
        smaller than the actual PMTU size. This allows the sender to increase
        the PLPMTU following a change in the characteristics of the path, such
        as when a link is reconfigured with a larger MTU, or when there is a
        change in the set of links traversed by an end-to-end flow (e.g. after
        a routing or fail-over decision).</t>

	<t>Implementations use a search algorithm across the search range to
	determine the PLPMTU supported on a path.</t>

        <t>Implementations discover the search range by validating the
        minimum path MTU and then using the probe method to select a
        PROBED_SIZE less than or equal to the maximum PMTU_MAX. Where PMTU_MAX
        is the minimum of the local link MTU and EMTU_R (learned from the
        remote endpoint). The PMTU_MAX MAY be constrained by an application
        that has a maximum to the size of datagrams it wishes to send.</t>

        <t>Implementations MAY optimizse the search procedure by selecting
        step sizes from a table of common PMTU sizes.</t>

        <t>Implementations SHOULD select probe sizes to maximise the gain in
        PLPMTU each search step. Implementations ought to take into
        consideration useful probe size steps and a minimum useful gain in
        PLPMTU.</t>

        <t>xxx A future version of this section will detail example methods
        for selecting probe size values, but does not plan to mandate a single
        method. xxx</t>

      </section>

      <section anchor="Reduce"
               title="Reducing the PLPMTU: Confirming Path Characteristics">
        <t>If the DPLPMTUD method detects that a packet with the PLPMTU size
        is no supported by the network path, then the DLPMTUD method needs to
        validate the PLPMTU. This can happen when a validated PTB message is
        received, or another event that indicates the network path no longer
        sustains this packet size, such as a loss report from the PL</t>

        <t>All implementations of DPLPMTUD are REQUIRED to provide support
        that reduces the PLPMTU when the actual PMTU supported by a network
        path is less than the PLPMTU.</t>

        <section anchor="mechanism-blackhole"
                 title="Black Hole Detection: Detecting path changes">

          <t>The DPLPMTUD method can be used to provide black hole detection.
          This enables a reduction of the PLPMTU when a PL sender encounters a
          path that fails to support the current MPS and also fails to return
          a PTB message to the sender.</t>

	  <t>Black Hole detection is performed by peridically sending
	  PROBED_SIZE probes at the PLPMTU estimate to verify the path still
	  supports the PLPMTU. Successive loss of probes is an indication that
	  path no longer supports the PLPMTU and traffic is being black
	  holed.</t>

          <t>The full method is specified in <xref target="States"></xref>.</t>
        </section>

        <section title="Simple Black Hole Detection State Machine">
	  <t>The simple method starts by setting the PROBED_SIZE to the PLPMTU.
	  When the method detects that communication is not possible with this
	  size of packet, the PLPMTU is reduced, until an operable message size
	  is reached or the PLPMTU reaches the BASE_MTU size. The method
	  enables a sending PL to inform an application of the reduced MPS and
	  accordingly send smaller packets.</t>

	  <t>The simple black hole detetction method does not seek to increase
	  the PLPMTU. This makes it vulnerable to transient reductions in the
	  actual PLPMTU, which could result in a PLPMTU lower than the actual
	  PMTU.</t>

	  <t>While a PL has a PLPMTU greater than the BASE_MTU, the PL needs to
	  send probe packets at the PROBED_SIZE to revalidate the PLPMTU.
	  Black hole detection can also be triggered by lack of reachability at
	  the PL. When the PL sender detects that multiple transmissions of
	  packets of PROBED_SIZE are no longer being acknowledged (e.g., When
	  the number of probe packets sent without receiving an acknowledgement
	  (PROBE_COUNT) becomes greater than the MAX_PROBES), the PL concludes
	  that it has detected a black hole and reduces PLPMTU.</t>

          <t>The connectivity check may be performened by the protocol
          implementing the PL (as in PLPMTUD for TCP <xref
          target="RFC4821"></xref>). When the application using the PL does
          not regularly send packets of size PROBED_SIZE, additional probe
          packets need to be sent by PL using the reachability timer <xref
          target="Timers"></xref>.</t>

	  <t>If method does reduces the PLPMTU below the MIN_PMTU, the method
	  concludes the path does not support the MIN_PMTU.</t>

          <t>If multihoming is supported, a state machine is needed for each
          active path.</t>

          <t>The state machine for a simple black hole detection mechanism is
          depicted in <xref target="fig-blackhole"></xref>.</t>

          <t>XXX a future version of the simple black hole detection state
          machine might consider ICMP PTB messages XXX</t>

          <t><figure anchor="fig-blackhole"
              title="State machine for detecting black holes">
              <artwork align="center"><![CDATA[
                        +------------+
                        | PROBE_START|
                        +-----+------+
                              | Connectivity confirmed
                              | (reachability tests start)
  PROBE_COUNT >=              V
  MAX_PROBES            +------------+
        +---------------| PROBE_BASE +->-+
        |               +-----+------+   |
        |                     |    ^     | PROBE_COUNT < MAX_PROBES
        |                     |    +-----+
        |                     V
        |                     | PROBE_ACK
        |   PROBE_COUNT       |
        |  = MAX_PROBES +------------+
        |  (reduce  +-<-+ PROBE_DONE +->-+
        |   PLPMTU) |   +------+-----+   |
        |           |     ^    |   ^     | PROBE_COUNT < MAX_PROBES
        |           |     |    |   |     |  (Continue probing)
        |           +-----+    |   +-----+
        V                      V
    +------------+             |
    | PROBE_ERROR|<------------+
    +------------+
]]></artwork>
            </figure></t>
        </section>
      </section>

      <section anchor="robustness"
               title="Robustness to inconsistent Path information">

	<t>XXX A future version of this document will include algorithms for
	dealing with robustness to inconsistent path information XXX</t>
	</section>

      <section title="Resilience to Inconsistent Path Information">
        <t>The decision to increase the PLPMTU needs to be resillient to the
        possibility that information learned about the path is inconsistent
        (this could happen when probe packets are lost due to other reasons,
        or some of the packets in a flow are forwarded along a portion of the
        path that supports a different PMTU).</t>

        <t>Frequent path changes could occur due to unexpected "flapping" -
        where some packets from a flow pass along one path, but other packets
        follow a different path with different properties. DPLPMTUD can be
        made resillient to these anomalies by introducing hysteresis into the
        decision to increase the Maximum Packet Size.</t>
      </section>

      <section anchor="States" title="Full State Machine">
        <t>A full state machine for DPLPMTUD is depicted in <xref
        target="fig-states"></xref>. If multihoming is supported, a state
        machine is needed for each active path.</t>

        <figure anchor="fig-states" title="State machine for Datagram PLPMTUD">
          <artwork align="center"><![CDATA[

                                      PROBE_TIMER expiry
                                   (PROBE_COUNT = MAX_PROBES)
                        +-------------+                +--------------+
                     +->| PROBE_START +--------------->|PROBE_DISABLED|
  PROBE_TIMER expiry |  +--+-------+--+                +--------------+
 (PROBE_COUNT =      |     |       |  
         MAX_PROBES) +-----+       |  Connectivity confirmed
                                   v
                  +---------- +------------+ -+ PROBE_TIMER expiry
MAX_PMTU acked or |           | PROBE_BASE |  | (PROBE_COUNT < 
PTB (>= BASE_PMTU)|    +----> +--------+---+ <+             MAX_PROBES)
  +---------------+    |          /\   |  |
  |                    |           |   |  | PTB
  |    PMTU_RAISE_TIMER|           |   |  | (PTB_SIZE < BASE_PMTU)
  |    or reachability |           |   |  |        or
  |     (PROBE_COUNT   |           |   |  |    PROBE_TIMER expiry
  |      = MAX_PROBES) |           |   |  | (PROBE_COUNT = MAX_PROBES)
  |        +-----------+           |   |   \      
  |        |                   PTB |   |    \  
  |        |        (< PROBED_SIZE)|   |     \ 
  |        |                       |   |      ---------------+
  |        |                       |   |                     |
  |        |                       |   | Probe               |
  |        |                       |   | acked               |
  v        |                       |   v                     v
+----------+-+                +----+---------+  Probe +-------------+
| PROBE_DONE |<-------------- | PROBE_SEARCH |<-------| PROBE_ERROR |
+------+-----+ MAX_PMTU acked +------------+-+  acked +-------------+
 /\    |             or            /\      |
  |    |      PROBE_TIMER expiry    |      |
  |    |(PROBE_COUNT = MAX_PROBES)  |      | 
  |    |                            |      |                 
  +----+                            +------+
Reachability probe acked      PROBE_TIMER expiry                     
 or PROBE_TIMER expiry      (PROBE_COUNT < MAX_PROBES)
(PROBE_COUNT < MAX_PROBES)            or
                                Probe acked

]]></artwork>
        </figure>

        <t></t>

        <t>XXX A future version of this document will update the state machine
        to describe handling of validated PTB messages. XXX</t>

        <t>The following states are defined to reflect the probing
        process:</t>

        <t><list style="hanging">
            <t hangText="PROBE_START:">The PROBE_START state is the initial
            state before probing has started. PLPMTUD is not performed in this
            state. The state transitions to PROBE_BASE, when a path has been
            confirmed, i.e. when a sent packet has been acknowledged on this
            path. Any transport method may be used to exit PROBE_BASE as long
            as the send packet is acknowledge by the other side. The PLPMTU is
            set to the BASE_PMTU size. Probing ought to start immediately
            after connection setup to prevent the prevent the loss of user
            data.</t>

            <t hangText="PROBE_BASE:">The PROBE_BASE state is the starting
            point for probing with datagram PLPMTUD. It is used to confirm
            whether the BASE_PMTU size is supported by the network path. On
            entry, the PROBED_SIZE is set to the BASE_PMTU size and the
            PROBE_COUNT is set to zero. A probe packet is sent, and the
            PROBE_TIMER is started. The state is left when the PROBE_COUNT
            reaches MAX_PROBES; a PTB message is validated, or a probe packet
            is acknowledged.</t>

            <t hangText="PROBE_SEARCH:">The PROBE_SEARCH state is the main
            probing state. This state is entered either when probing for the
            BASE_PMTU was successful or when there is a successful
            reachability test in the PROBE_ERROR state. On entry, the PLPMTU
            is set to the last acknowledged PROBED_SIZE.</t>

            <t hangText="">The PROBE_COUNT is set to zero when the first probe
            packet is sent for each probe size. Each time a probe packet is
            acknowledged, the PLPMTU is set to the PROBED_SIZE, and then the
            PROBED_SIZE is increased.</t>

            <t hangText="">When a probe packet is sent and not acknowledged
            within the period of the PROBE_TIMER, the PROBE_COUNT is
            incremented and the probe packet is retransmitted. The state is
            exited when the PROBE_COUNT reaches MAX_PROBES; a PTB message is
            validated; or a probe of size PMTU_MAX is acknowledged.</t>

            <t hangText="PROBE_ERROR:">The PROBE_ERROR state represents the
            case where the network path is not known to support an PLPMTU of
            at least the BASE_PMTU size. It is entered when either a probe of
            size BASE_PMTU has not been acknowledged or a validated PTB
            message indicates a smaller link MTU than the BASE_PMTU. On entry,
            the PROBE_COUNT is set to zero and the PROBED_SIZE is set to the
            MIN_PMTU size, and the PLPMTU is reset to MIN_PMTU size. In this
            state, a probe packet is sent, and the PROBE_TIMER is started. The
            state transitions to the PROBE_SEARCH state when a probe packet is
            acknowledged.</t>

            <t hangText="PROBE_DONE:">The PROBE_DONE state indicates a
            successful end to a probing phase. DPLPMTUD remains in this state
            until either the PMTU_RAISE_TIMER expires or a received PTB
            message is validated.</t>

            <t hangText="">When DPLPMTUD uses an unacknowledged PL and is in
            the PROBE_DONE state, a REACHABILITY_TIMER periodically resets the
            PROBE_COUNT and schedules a probe packet with the size of the
            PLPMTU. If the probe packet fails to be acknowledged after
            MAX_PROBES attempts, the method enters the PROBE_BASE state. When
            used with an acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD NOT
            continue to probe in this state.</t>

            <t hangText="PROBE_DISABLED:">The PROBE_DISABLED state indicates
            that connectivity could not be established. DPLPMTUD MUST NOT
            probe in this state.</t>
          </list><xref target="StateChanges"></xref> contains an informative
        description of key events.</t>
      </section>
    </section>
    </section>

    <section anchor="protocol_specific_methods"
             title="Specification of Protocol-Specific Methods">
      <t>This section specifies protocol-specific details for datagram PLPMTUD
      for IETF-specified transports.</t>

      <t>The first subsection provides guidance on how to implement the
      DPLPMTUD method as a part of an application using UDP or UDP-Lite. The
      guidance also applies to other datagram services that do not include a
      specific transport protocol (such as a tunnel encapsulation). The
      following subsection describe how DPLPMTUD can be implemented as a part
      of the transport service, allowing applications using the service to
      benefit from discovery of the PLPMTU without themselves needing to
      implement this method.</t>

      <section title="Application support for DPLPMTUD with UDP or UDP-Lite">
        <t>The current specifications of UDP <xref target="RFC0768"></xref>
        and UDP-Lite <xref target="RFC3828"></xref> do not define a method in
        the RFC-series that supports PLPMTUD. In particular, the UDP transport
        does not provide the transport layer features needed to implement
        datagram PLPMTUD.</t>

        <t>The DPLPMTUD method can be implemented as a part of an application
        built directly or indirectly on UDP or UDP-Lite, but relies on
        higher-layer protocol features to implement the method <xref
        target="RFC8085"></xref>.</t>

        <t>Some primitives used by DPLPMTUD might not be available via the
        Datagram API (e.g., the ability to access the PLPMTU cache, or
        interpret received ICMP PTB messages).</t>

        <t>In addition, it is desirable that PMTU discovery is not performed
        by multiple protocol layers. An application SHOULD avoid implementing
        DPLPMTUD when the underlying transport system provides this
        capability. Using a common method for manging the PLPMTU has benefits,
        both in the ability to share state between different processes and
        opportunities to coordinate probing.</t>

        <section anchor="UDP-REQ" title="Application Request ">
          <t>An application needs an application-layer protocol mechanism
          (such as a message acknowledgement method) that solicits a response
          from a destination endpoint. The method SHOULD allow the sender to
          check the value returned in the response to provide additional
          protection from off-path insertion of data <xref
          target="RFC8085"></xref>, suitable methods include a parameter known
          only to the two endpoints, such as a session ID or initialised
          sequence number.</t>
        </section>

        <section anchor="UDP-Probe" title="Application Response ">
          <t>An application needs an application-layer protocol mechanism to
          communicate the response from the destination endpoint. This
          response may indicate successful reception of the probe across the
          path, but could also indicate that some (or all packets) have failed
          to reach the destination.</t>
        </section>

        <section anchor="UDP-probing"
                 title="Sending Application Probe Packets">
          <t>A probe packet that may carry an application data block, but the
          successful transmission of this data is at risk when used for
          probing. Some applications may prefer to use a probe packet that
          does not carry an application data block to avoid disruption to
          normal data transfer.</t>
        </section>

        <section title="Validating the Path ">
          <t>An application that does not have other higher-layer information
          confirming correct delivery of datagrams SHOULD implement the
          REACHABILITY_TIMER to periodically send probe packets while in the
          PROBE_DONE state.</t>
        </section>

        <section anchor="udpopt_ptb_handling" title="Handling of PTB Messages">
          <t>An application that is able and wishes to receive PTB messages
          MUST perform ICMP validation as specified in Section 5.2 of <xref
          target="RFC8085"></xref>. This requires that the application to
          check each received PTB messages to validate it is received in
          response to transmitted traffic and that the reported link MTU is
          less than the current probe size. A validated PTB message MAY be
          used as input to the DPLPMTUD algorithm, but MUST NOT be used
          directly to set the PLPMTU.</t>
        </section>
      </section>

      <section anchor="UDPOPT-PLPMTUD" title="DPLPMTUD with UDP Options">
        <t>UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref> can
        supply the additional functionality required to implement DPLPMTUD
        within the UDP transport service. This avoids the need for
        applications to implement the DPLPMTUD method.</t>

        <t>This enables padding to be added to UDP datagrams and can be used
        to provide feedback acknowledgement of received probe packets.</t>

        <t>The specification also defines two UDP Options to support
        DPLMTUD.</t>

        <t>Section 5.6 of <xref target="I-D.ietf-tsvwg-udp-options"></xref>
        defines the MSS option which allows the local sender to indicate the
        EMTU_R to the peer. This option can be used to initialise PMTU_MAX. An
        application wishing to avoid the effects of MSS-Clamping (where a
        middlebox changes the advertised TCP maximum sending size) ought to
        use a cryptographic method to encrypt this parameter.</t>

        <section anchor="UDPOPT-ECHOREQ" title="UDP Request Option">
          <t>The Request Option allows a sending endpoint to solicit a
          response from a destination endpoint.</t>

          <t>The Request Option carries a four byte token set by the sender.
          This token can be set to a value that is likely to be known only to
          the sender (and becomes known to nodes along the end-to-end path).
          The sender can then check the value returned in the response to
          provide additional protection from off-path insertion of data <xref
          target="RFC8085"></xref>.</t>

          <figure anchor="fig-echoreq" title="UDP REQ Option Format">
            <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=9  | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
          </figure>
        </section>

        <section anchor="UDPOPT-ECHORES" title="UDP Response Option">
          <t>The Response Option is generated by the PL in response to
          reception of a previously received Echo Request. The Token field
          associates the response with the Token value carried in the most
          recently-received Echo Request. The rate of generation of UDP
          packets carrying a Response Option MAY be rate-limited.</t>

          <figure anchor="fig-echores" title="UDP RES Option Format">
            <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=10 | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
          </figure>
        </section>
      </section>

      <section title="DPLPMTUD for SCTP">
        <t>Section 10.2 of <xref target="RFC4821"></xref> specifies a
        recommended PLPMTUD probing method for SCTP. It recommends the use of
        the PAD chunk, defined in <xref target="RFC4820"></xref> to be
        attached to a minimum length HEARTBEAT chunk to build a probe packet.
        This enables probing without affecting the transfer of user messages
        and without interfering with congestion control. This is preferred to
        using DATA chunks (with padding as required) as path probes.</t>

        <t>XXX Future versions of this document might define a parameter
        contained in the INIT and INIT ACK chunk to indicate the remote peer
        MTU to the local peer. However, multihoming makes this a bit complex,
        so it might not be worth doing. XXX</t>

        <section anchor="sctp_over_ip" title="SCTP/IP4 and SCTP/IPv6">
          <t>The base protocol is specified in <xref target="RFC4960"></xref>.
          This provides an acknowledged PL. A sender can therefore enter the
          PROBE_BASE state as soon as connectivity has been confirmed.</t>

          <section anchor="sctp_over_ip_probing"
                   title="Sending SCTP Probe Packets">
            <t>Probe packets consist of an SCTP common header followed by a
            HEARTBEAT chunk and a PAD chunk. The PAD chunk is used to control
            the length of the probe packet. The HEARTBEAT chunk is used to
            trigger the sending of a HEARTBEAT ACK chunk. The reception of the
            HEARTBEAT ACK chunk acknowledges reception of a successful
            probe.</t>

            <t>The HEARTBEAT chunk carries a Heartbeat Information parameter
            which should include, besides the information suggested in <xref
            target="RFC4960"></xref>, the probe size, which is the size of the
            complete datagram. The size of the PAD chunk is therefore computed
            by reducing the probing size by the IPv4 or IPv6 header size, the
            SCTP common header, the HEARTBEAT request and the PAD chunk
            header. The payload of the PAD chunk contains arbitrary data.</t>

            <t>To avoid fragmentation of retransmitted data, probing starts
            right after the handshake, before data is sent. Assuming normal
            behaviour (i.e., the PMTU is smaller than or equal to the
            interface MTU), this process will take a few round trip time
            periods depending on the number of PMTU sizes probed. The
            Heartbeat timer can be used to implement the PROBE_TIMER.</t>
          </section>

          <section title="Validating the Path with SCTP">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_ip_ptb_handling"
                   title="PTB Message Handling by SCTP">
            <t>Normal ICMP validation MUST be performed as specified in
            Appendix C of <xref target="RFC4960"></xref>. This requires that
            the first 8 bytes of the SCTP common header are quoted in the
            payload of the PTB message, which can be the case for ICMPv4 and
            is normally the case for ICMPv6.</t>

            <t>When a PTB message has been validated, the router Link MTU
            indicated in the PTB message SHOULD be used with the DPLPMTUD
            algorithm, providing that the reported Link MTU is less than the
            current probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/UDP">
          <t>The UDP encapsulation of SCTP is specified in <xref
          target="RFC6951"></xref>.</t>

          <section anchor="sctp_over_udp_probing"
                   title="Sending SCTP/UDP Probe Packets">
            <t>Packet probing can be performed as specified in <xref
            target="sctp_over_ip_probing"></xref>. The maximum payload is
            reduced by 8 bytes, which has to be considered when filling the
            PAD chunk.</t>
          </section>

          <section title="Validating the Path with SCTP/UDP ">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_udp_ptb_handling"
                   title="Handling of PTB Messages by SCTP/UDP">
            <t>Normal ICMP validation MUST be performed for PTB messages as
            specified in Appendix C of <xref target="RFC4960"></xref>. This
            requires that the first 8 bytes of the SCTP common header are
            contained in the PTB message, which can be the case for ICMPv4
            (but note the UDP header also consumes a part of the quoted packet
            header) and is normally the case for ICMPv6. When the validation
            is completed, the router Link MTU size indicated in the PTB
            message SHOULD be used with the DPLPMTUD providing that the
            reported link MTU is less than the current probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/DTLS">
          <t>The Datagram Transport Layer Security (DTLS) encapsulation of
          SCTP is specified in <xref target="RFC8261"></xref>. It is used for
          data channels in WebRTC implementations.</t>

          <section anchor="sctp_over_dtls_probing"
                   title="Sending SCTP/DTLS Probe Packets">
            <t>Packet probing can be done as specified in <xref
            target="sctp_over_ip_probing"></xref>.</t>
          </section>

          <section title="Validating the Path with SCTP/DTLS">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_dtls_ptb_handling"
                   title="Handling of PTB Messages by SCTP/DTLS">
            <t>It is not possible to perform normal ICMP validation as
            specified in <xref target="RFC4960"></xref>, since even if the
            ICMP message payload contains sufficient information, the
            reflected SCTP common header would be encrypted. Therefore it is
            not possible to process PTB messages at the PL.</t>
          </section>
        </section>
      </section>

      <section title="DPLPMTUD for QUIC">
        <t>Quick UDP Internet Connection (QUIC) <xref
        target="I-D.ietf-quic-transport"></xref> is a UDP-based transport that
        provides reception feedback.</t>

        <t>Section 9.2 of <xref target="I-D.ietf-quic-transport"></xref>
        describes the path considerations when sending QUIC packets. It
        recommends the use of PADDING frames to build the probe packet. This
        enables probing the without affecting the transfer of other QUIC
        frames.</t>

        <t>This provides an acknowledged PL. A sender can therefore enter the
        PROBE_BASE state as soon as connectivity has been confirmed.</t>

        <section title="Sending QUIC Probe Packets">
          <t>A probe packet consists of a QUIC Header and a payload containing
          only PADDING Frames. PADDING Frames are a single octet (0x00) and
          several of these can be used to create a probe packet of size
          PROBED_SIZE. QUIC provides an acknowledged PL. A sender can
          therefore enter the PROBE_BASE state as soon as connectivity has
          been confirmed.</t>

          <t>The current specification of QUIC sets the following:<list
              style="symbols">
              <t>BASE_PMTU: 1200. A QUIC sender needs to pad initial packets
              to 1200 bytes to validate the path can support packets of a
              useful size.</t>

              <t>MIN_PMTU: 1200 bytes. A QUIC sender that determines the PMTU
              has fallen below 1200 bytes MUST immediately stop sending on the
              affected path.</t>
            </list></t>
        </section>

        <section title="Validating the Path with QUIC">
          <t>QUIC provides an acknowledged PL. A sender therefore MUST NOT
          implement the REACHABILITY_TIMER while in the PROBE_DONE state.</t>
        </section>

        <section title="Handling of PTB Messages by QUIC">
          <t>QUIC operates over the UDP transport, and the guidelines on ICMP
          validation as specified in Section 5.2 of <xref
          target="RFC8085"></xref> therefore apply. Although QUIC does not
          currently specify a method for validating ICMP responses, it does
          provide some guidelines to make it harder for an off-path attacker
          to inject ICMP messages.</t>

          <t><list style="symbols">
              <t>Set the IPv4 Don't Fragment (DF) bit on a small proportion of
              packets, so that most invalid ICMP messages arrive when there
              are no DF packets outstanding, and can therefore be identified
              as spurious.</t>

              <t>Store additional information from the IP or UDP headers from
              DF packets (for example, the IP ID or UDP checksum) to further
              authenticate incoming Datagram Too Big messages.</t>

              <t>Any reduction in PMTU due to a report contained in an ICMP
              packet is provisional until QUIC's loss detection algorithm
              determines that the packet is actually lost.</t>
            </list></t>

          <t>XXX The above list was pulled whole from quic-transport - input
          is invited from QUIC contributors. XXX</t>
        </section>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This work was partially funded by the European Union's Horizon 2020
      research and innovation programme under grant agreement No. 644334
      (NEAT). The views expressed are solely those of the author(s).</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

      <t>XXX If new UDP Options are specified in this document, a request to
      IANA will be included here. XXX</t>

      <t>If there are no requirements for IANA, the section will be removed
      during conversion into an RFC by the RFC Editor.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security considerations for the use of UDP and SCTP are provided
      in the references RFCs. Security guidance for applications using UDP is
      provided in the UDP Usage Guidelines <xref target="RFC8085"></xref>.</t>

      <t>There are cases where PTB messages are not delivered due to policy,
      configuration or equipment design (see <xref
      target="Classic-PMTUD"></xref>), this method therefore does not rely
      upon PTB messages being received, but is able to utilise these when they
      are received by the sender. PTB messages could potentially be used to
      cause a node to inappropriately reduce the PLPMTU. A node supporting
      DPLPMTUD MUST therefore appropriately validate the payload of PTB
      messages to ensure these are received in response to transmitted traffic
      (i.e., a reported error condition that corresponds to a datagram
      actually sent by the path layer.</t>

      <t>Parallel forwarding paths may need to be considered. <xref
      target="robustness"></xref> identifies the need for robustness in the
      method when the path information may be inconsistent.</t>

      <t>A node performing DPLPMTUD could experience conflicting information
      about the size of supported probe packets. This could occur when there
      are multiple paths are concurrently in use and these exhibit a different
      PMTU. If not considered, this could result in data being black holed
      when the PLPMTU is larger than the smallest PMTU across the current
      paths.</t>

      <t>An on-path attacker could forge PTB messages to drive down the
      PLPMTU</t>
    </section>
  </middle>

  <back>
    <!-- References split into informative and normative -->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC792;

      &RFC768;

      &RFC1122;

      &RFC1812;

      &RFC2119;

      &RFC2460;

      &RFC3828;

      &RFC8085;

      &RFC4820;

      &RFC4960;

      &RFC6951;

      &RFC8201;

      &RFC8261;

      &I-D.ietf-tsvwg-udp-options;

      &I-D.ietf-quic-transport;
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC1191;

      &RFC4821;

      &RFC2923;

      &RFC4340;

      &RFC4890;
    </references>

    <section anchor="StateChanges" title="Event-driven state changes">
      <t>This appendix contains an informative description of key events:</t>

      <t><list style="hanging">
          <t hangText="Path Setup:">When a new path is initiated, the state is
          set to PROBE_START. As soon as the path is confirmed, the state
          changes to PROBE_BASE and probing for this path is started. The
          first probe packet is sent with the size of the BASE_PMTU.</t>

          <t hangText="Arrival of an Acknowledgment:">Depending on the probing
          state, the reaction differs according to <xref
          target="fig-acks"></xref>, which is a simplification of <xref
          target="fig-states"></xref> focusing on this event. <figure
              anchor="fig-acks"
              title="State changes at the arrival of an acknowledgment">
              <artwork align="center"><![CDATA[
+--------------+                                    +----------------+
|  PROBE_START | --3------------------------------->| PROBE_DISABLED |
+--------------+ --4-----------\                    +----------------+
                                \
+--------------+                 \
| PROBE_ERROR  | ---------------  \
+--------------+                \  \
                                 \  \
+--------------+                  \  \              +--------------+
|  PROBE_BASE  | --1----------     \  ------------> |  PROBE_BASE  |
+--------------+ --2-----     \     \               +--------------+
                         \     \     \
+--------------+          \     \     ------------> +--------------+
| PROBE_SEARCH | --2---    \     -----------------> | PROBE_SEARCH |
+--------------+ --1---\----\---------------------> +--------------+
                        \    \
+--------------+         \    \                     +--------------+
|  PROBE_DONE  |          \    -------------------> |  PROBE_DONE  |
+--------------+           -----------------------> +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum PMTU size has not yet been
              reached. Condition 2: The maximum PMTU size has been reached.
              Conition 3: Probe Timer expires and PROBE_COUNT = MAX_PROBEs.
              Condition 4: PROBE_ACK received.</postamble>
            </figure></t>

          <t hangText="Probing timeout:">The PROBE_COUNT is initialised to
          zero each time the value of PROBED_SIZE is changed and when a
          acknowledgment confirming delivery of a probe packet arries. The
          PROBE_TIMER is started each time a probe packet is sent. It is
          stopped when an acknowledgment arrives that confirms delivery of a
          probe packet of PROBED_SIZE. If the probe packet is not acknowledged
          before the PROBE_TIMER expires, the PROBE_COUNT is incremented. When
          the PROBE_COUNT equals the value MAX_PROBES, the state is changed,
          otherwise a new probe packet of the same size (PROBED_SIZE) is
          resent. The state transitions are illustrated in <xref
          target="fig-probeTimer"></xref>. This shows a simplification of
          <xref target="fig-states"></xref> with a focus only on this event.
          <figure anchor="fig-probeTimer"
              title="State changes at the expiration of the probe timer">
              <artwork align="center"><![CDATA[
+--------------+                                    +----------------+
|  PROBE_START |----------------------------------->| PROBE_DISABLED |
+--------------+                                    +----------------+

+--------------+                                    +--------------+
| PROBE_ERROR  |                 -----------------> | PROBE_ERROR  |
+--------------+                /                   +--------------+
                               /
+--------------+ --2----------/                     +--------------+
|  PROBE_BASE  | --1------------------------------> |  PROBE_BASE  |
+--------------+                                    +--------------+

+--------------+                                    +--------------+
| PROBE_SEARCH | --1------------------------------> | PROBE_SEARCH |
+--------------+ --2---------                       +--------------+
                             \
+--------------+              \                     +--------------+
|  PROBE_DONE  |               -------------------> |  PROBE_DONE  |
+--------------+                                    +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum number of probe packets has
              not been reached. Condition 2: The maximum number of probe
              packets has been reached.</postamble>
            </figure></t>

          <t hangText="PMTU raise timer timeout:">The path through the network
          can change over time. It impossible to discover whether a path
          change has increased the actual PMTU by exchanging packets less than
          or equal to the PLPMTU. This requires DPLPMTUD to periodically send a
          probe packet to detect whether a larger PMTU is possible. This probe
          packet is generated by the PMTU_RAISE_TIMER. When the timer expires,
          probing is restarted with the BASE_PMTU and the state is changed to
          PROBE_BASE.</t>

          <t hangText="Arrival of a PTB message:">The active probing of the
          path can be supported by the arrival of a PTB message sent by a
          router or middleboxes indicating the router's local link MTU. Two
          cases can be distinguished:</t>

          <t><list style="numbers">
              <t>The indicated link MTU in the PTB message is between the
              already probed and PLPMTU and the probe that triggered the PTB
              message.</t>

              <t>The indicated link MTU in the PTB message is smaller than the
              PLPMTU.</t>
            </list></t>

          <t>In first case, the PROBE_BASE state transitions to the
          PROBE_ERROR state. In the PROBE_SEARCH state, a new probe packet is
          sent with the sized reported by the PTB message. Its result is
          handled according to the former events.</t>

          <t>The second case could be a result of a network re-configuration.
          If the reported link MTU in the PTB message is greater than the
          BASE_MTU, the probing starts again with a value of PROBE_BASE.
          Otherwise, the method enters the state PROBE_ERROR.</t>

          <t>Note: Not all routers include the link MTU size when they send a
          PTB message. If the PTB message does not indicate the link MTU, the
          probe is handled in the same way as condition 2 of <xref
          target="fig-probeTimer"></xref>.</t>
        </list></t>
    </section>

    <section title="Revision Notes">
      <t>Note to RFC-Editor: please remove this entire section prior to
      publication.</t>

      <t>Individual draft -00: <list style="symbols">
          <t hangText="Individual draft -00">Comments and corrections are
          welcome directly to the authors or via the IETF TSVWG working group
          mailing list.</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Individual draft -01:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">Contains the first representation
          of the algorithm, showing the states and timers</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Individual draft -02:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">Contains updated representation
          of the algorithm, and textual corrections.</t>

          <t hangText="Individual draft -00">The text describing when to set
          the effective PMTU has not yet been validated by the authors</t>

          <t hangText="Individual draft -00">To determine security to
          off-path-attacks: We need to decide whether a received PTB message
          SHOULD/MUST be validated? The text on how to handle a PTB message
          indicating a link MTU larger than the probe has yet not been
          validated by the authors</t>

          <t hangText="Individual draft -00">No text currently describes how
          to handle inconsistent results from arbitrary re-routing along
          different parallel paths</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Working Group draft -00:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">This draft follows a successful
          adoption call for TSVWG</t>

          <t hangText="Individual draft -00">There is still work to complete,
          please comment on this draft.</t>
        </list>Working Group draft -01:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">This draft includes improved
          introduction.</t>

          <t hangText="Individual draft -00">The draft is updated to require
          ICMP validation prior to accepting PTB messages - this to be
          confirmed by WG</t>

          <t hangText="Individual draft -00">Section added to discuss
          Selection of Probe Size - methods to be evlauated and
          recommendations to be considered</t>

          <t hangText="Individual draft -00">Section added to align with work
          proposed in the QUIC WG.</t>
        </list>Working Group draft -02:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">The draft was updated based on
          feedback from the WG, and a detailed review by Magnus
          Westerlund.</t>

          <t hangText="Individual draft -00">The document updates RFC
          4821.</t>

          <t hangText="Individual draft -00">Requirements list updated.</t>

          <t hangText="Individual draft -00">Added more explicit discussion of
          a simpler black-hole detection mode.</t>

          <t hangText="Individual draft -00">This draft includes
          reorganisation of the section on IETF protocols.</t>

          <t hangText="Individual draft -00">Added more discussion of
          implementation within an application.</t>

          <t hangText="Individual draft -00">Added text on flapping paths.</t>

          <t hangText="Individual draft -00">Replaced 'effective MTU' with new
          term PLPMTU.</t>
        </list>Working Group draft -03:</t>

      <t><list style="symbols">
          <t>Updated figures</t>

          <t>Added more discussion on blackhole detection</t>

          <t>Added figure describing just blackhole detection</t>

          <t>Added figure relating MPS sizes</t>

          <t>Updated full state machine artwork for clarity</t>

          <t>Changed all text to refer to /packet probes/ /validation/ (rather
          than /verification/).</t>
        </list></t>
    </section>
  </back>
</rfc>
