<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0678.xml">
<!ENTITY RFC768 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC792 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC1122 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1123 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1812 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1812.xml">
<!ENTITY RFC1191 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1981 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2475 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2475.xml">
<!ENTITY RFC2553 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2553.xml">
<!ENTITY RFC2923 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2923.xml">
<!ENTITY RFC3168 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3260 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3260.xml">
<!ENTITY RFC3395 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3395.xml">
<!ENTITY RFC3396 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3396.xml">
<!ENTITY RFC3493 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3678 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3678.xml">
<!ENTITY RFC3828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC4340 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4820 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4828 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4828.xml">
<!ENTITY RFC4890 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4890.xml">
<!ENTITY RFC4960 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5082 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5082.xml">
<!ENTITY RFC5097 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5226 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC6679 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6679.xml">
<!ENTITY RFC6935 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC6968 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6968.xml">
<!ENTITY RFC6633 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6633.xml">
<!ENTITY RFC8085 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml">
<!ENTITY RFC8201 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml">
<!ENTITY I-D.ietf-tsvwg-udp-options SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-udp-options-01.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-dtls-encaps SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-sctp-dtls-encaps-09.xml">
<!ENTITY I-D.ietf-quic-transport SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-quic-transport-04.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-tsvwg-datagram-plpmtud-03"
     ipr="trust200902" updates="4821">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
                 or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
     full title is longer than 39 characters -->

    <title abbrev="DPLPMTUD ">Packetization Layer Path MTU Discovery for
    Datagram Transports</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3U</code>

          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Tom Jones" initials="T" surname="Jones">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3U</code>

          <country>UK</country>
        </postal>

        <email>tom@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Michael Tuexen" initials="M" surname="Tuexen">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Stein fart</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>

    <author fullname="Irene Ruengeler" initials="I" surname="Ruengeler">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Stein fart</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>i.ruengeler@fh-muenster.de</email>
      </address>
    </author>

    <date day="08" month="June" year="2018" />

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
     IETF is fine for individual submissions. If this element is not
     present, the default is "Network Working Group", which is used by the
     RFC Editor as a nod to the history of the IETF. -->

    <keyword>UDP SCTP Transport PMTUD PLPMTUD</keyword>

    <!-- Keywords will be incorporated into HTML output
     files in a meta tag but they have no effect on text or nroff output. If
     you submit your draft to the RFC Editor, the keywords will be used for
     the search engine. -->

    <abstract>
      <t>This document describes a robust method for Path MTU Discovery
      (PMTUD) for datagram Packetization layers. The document describes an
      extension to RFC 1191 and RFC 8201, which specifies ICMP-based Path MTU
      Discovery for IPv4 and IPv6. The method allows a Packetization Layer
      (PL), or a datagram application that uses a PL, to discover whether a
      network path can support the current size of datagram and to probe a
      network path with progressively larger packets to find whether the
      maxium packet size can be increased. This allows a sender to determine
      an appropriate packet size. This provides functionally for datagram
      transports that is equivalent to the Packetization layer PMTUD
      specification for TCP, specified in RFC4821.</t>

      <t>The document also provides implementation notes for incorporating
      Datagram PMTUD into IETF Datagram transports or applications that use
      transports.</t>

      <t>When published, this specification updates RFC4821.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The IETF has specified datagram transport using UDP, SCTP, and DCCP,
      as well as protocols layered on top of these transports (e.g., SCTP/UDP,
      DCCP/UDP) and directly over the IP network layer. This document
      describes a robust method for Path MTU Discovery (PMTUD) that may be
      used with these transport protocols (or the applications that use their
      transport service) to discover an appropriate size of packet to use
      across an Internet path.</t>

      <section anchor="Classic-PMTUD" title="Classical Path MTU Discovery">
        <t>Classical Path Maximum Transmission Unit Discovery (PMTUD) can be
        used with any transport that is able to process ICMP Packet Too Big
        (PTB) messages (e.g., <xref target="RFC1191"></xref> and <xref
        target="RFC8201"></xref>). The term PTB message is applied to both
        IPv4 ICMP Unreachable messages (type 3) that carry the error
        Fragmentation Needed (Type 3, Code 4) and ICMPv6 packet too big
        messages (Type 2). When a sender receives a PTB message, it reduces
        the effective MTU to the value reported as the Link MTU in the PTB
        message, and a method that from time-to-time increases the packet size
        in attempt to discover an increase in the supported PMTU. The packets
        sent with a size larger than the current effective PMTU are known as
        probe packets.</t>

        <t>Packets not intended as probe packets are either fragmented to the
        current effective PMTU, or the attempt to send fails with an error
        code. Applications are sometimes provided with a primitive to let them
        read the maximum packet size, derived from the current effective
        PMTU.</t>

        <t>Classical PMTUD is subject to protocol failures. One failure arises
        when traffic using a packet size larger than the actual PMTU is
        black-holed (all datagrams sent with this size, or larger, are
        silently discarded without the sender receiving ICMP PTB messages).
        This could arise when the PTB messages are not delivered back to the
        sender for some reason <xref target="RFC2923"></xref>). For example,
        ICMP messages are increasingly filtered by middleboxes (including
        firewalls) <xref target="RFC4890"></xref>. A stateful firewall could
        be configured with a policy to block incoming ICMP messages, which
        would prevent reception of PTB messages to endpoints behind this
        firewall. Other examples include cases where PTB messages are not
        correctly processed/generated by tunnel endpoints.</t>

        <t>Another failure could result if a node that is not on the network
        path sends a PTB message that attempts to force the sender to change
        the effective PMTU <xref target="RFC8201"></xref>. A sender can
        protect itself from reacting to such messages by utilising the quoted
        packet within a PTB message payload to verify that the received PTB
        message was generated in response to a packet that had actually
        originated from the sender. However, there are situations where a
        sender would be unable to provide this verification.</t>

        <t>Examples where verification is not possible include:</t>

        <t><list style="symbols">
            <t>When the router issuing the ICMP message is acting on a
            tunneled packet, the ICMP message will be directed to the tunnel
            endpoint. This tunnel endpoint is responsible for forwardiung the
            ICMP message and also processing the quoted packet within the
            payload field to remove the effect of the tunnel, and return a
            correctly fromatted ICMP message to the sender. Failure to do this
            results in black-holing.</t>

            <t>When a router issuing the ICMP message implements RFC792 <xref
            target="RFC0792"></xref>, it is only required the to include the
            first 64 bits of the IP payload of the packet within the quoted
            payload.This may be insufficient to perfom the tunnel processing
            described in the previous bullet. Even if the decapsulated message
            is processed by the tunnel endpoint, there could be insufficient
            bytes remaining for the sender to interpret the quoted transport
            information. RFC1812 <xref target="RFC1812"></xref> requires
            routers to return the full packet if possible, often the case for
            IPv4 when used the path includes tunnels; or where the packet has
            been encapsulated/tunneled over an encrypted transport and it is
            not possible to determine the original transport header ).</t>

            <t>Even when the PTB message includes sufficient bytes of the
            quoted packet, the network layer could lack sufficient context to
            perform verification, because this depends on information about
            the active transport flows at an endpoint node (e.g., the
            socket/address pairs being used, and other protocol header
            information).</t>
          </list></t>
      </section>

      <section title="Packetization Layer Path MTU Discovery">
        <t>The term Packetization Layer (PL) has been introduced to describe
        the layer that is responsible for placing data blocks into the payload
        of IP packets and selecting an appropriate Maximum Packet Size (MPS).
        This function is often performed by a transport protocol, but can also
        be performed by other encapsulation methods working above the
        transport.</t>

        <t>In contrast to PMTUD, Packetization Layer Path MTU Discovery
        (PLPMTUD) <xref target="RFC4821"></xref> does not rely upon reception
        and verification of PTB messages. It is therefore more robust than
        Classical PMTUD. This has become the recommended approach for
        implementing PMTU discovery with TCP.</t>

        <t>It uses a general strategy where the PL sends probe packet to
        search for the largest size of unfragmented datagram that can be sent
        over a path. The probe packets are sent with a progressively larger
        packet size. If a probe packet is successfully delivered (as
        determined by the PL), then the PLPMTU is raised to the size of the
        successful probe. If no response is received to a probe packet, the
        method reduces the probe size. This PLPMTU is used to set the
        application MPS.</t>

        <t>PLPMTUD introduces flexibility in the implementation of PMTU
        discovery. At one extreme, it can be configured to only perform PTB
        black hole detection and recovery to increase the robustness of
        Classical PMTUD, or at the other extreme, all PTB processing can be
        disabled and PLPMTUD can completely replace Classical PMTUD.</t>

        <t>PLPMTUD can also include additional consistency checks without
        increasing the risk of increased black-holing. For instance,the
        information available at the PL, or higher layers, makes PTB
        verification more straight forward.</t>
      </section>

      <section title="Path MTU Discovery for Datagram Services">
        <t><xref target="Spec"></xref> of this document presents a set of
        algorithms for datagram protocols to discover the largest size of
        unfragmented datagram that can be sent over a path. The method
        described relies on features of the PL <xref
        target="Requirements"></xref> and apply to transport protocols
        operating over IPv4 and IPv6. It does not require cooperation from the
        lower layers, although it can utilise ICMP PTB messages when these
        received messages are made available to the PL.</t>

        <t>The UDP Usage Guidelines <xref target="RFC8085"></xref> state "an
        application SHOULD either use the Path MTU information provided by the
        IP layer or implement Path MTU Discovery (PMTUD)", but does not
        provide a mechanism for discovering the largest size of unfragmented
        datagram than can be used on a path. Prior to this document, PLPMTUD
        had not been specified for UDP.</t>

        <t>Section 10.2 of <xref target="RFC4821"></xref> recommends a PLPMTUD
        probing method for the Stream Control Transport Protocol (SCTP). SCTP
        utilises heartbeat messages as probe packets, but RFC4821 does not
        provide a complete specification. This document provides the details
        to complete that specification.</t>

        <t>The Datagram Congestion Control Protocol (DCCP) <xref
        target="RFC4340"></xref> requires implementations to support Classical
        PMTUD and states that a DCCP sender "MUST maintain the MPS allowed for
        each active DCCP session". It also defines the current congestion
        control MPS (CCMPS) supported by a path. This recommends use of PMTUD,
        and suggests use of control packets (DCCP-Sync) as path probe packets,
        because they do not risk application data loss. The method defined in
        this specification could be used with DCCP.</t>

        <t><xref target="protocol_specific_methods"></xref> specifies the
        method for a set of transports, and provides information to enables
        the implementation of PLPMTUD with other datagram transports and
        applications that use datagram transports.</t>
      </section>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      <t>Other terminology is directly copied from <xref
      target="RFC4821"></xref>, and the definitions in <xref
      target="RFC1122"></xref>.</t>

      <t><list style="hanging">
          <t hangText="Black-Holed:">When the sender is unaware that packets
          are not delivered to the destination endpoint (e.g., when the sender
          transmits packets of a particular size with a previously known
          effective PMTU (also refered to as the PLPMTU), but is unaware of a
          change to the path that resulted in a smaller PLPMTU).</t>

          <t hangText="Classical Path MTU Discovery:">Classical PMTUD is a
          process described in <xref target="RFC1191"></xref> and <xref
          target="RFC8201"></xref>, in which nodes rely on PTB messages to
          learn the largest size of unfragmented datagram than can be used
          across a path.</t>

          <t hangText="Datagram:">A datagram is a transport-layer protocol
          data unit, transmitted in the payload of an IP packet.</t>

          <t hangText="Effective PMTU:">The current estimated value for PMTU
          that is used by a PMTUD. This is equivalent to the PLPMTU derived by
          PLPMTUD.</t>

          <t hangText="EMTU_S:">The Effective MTU for sending (EMTU_S) is
          defined in <xref target="RFC1122"></xref> as "the maximum IP
          datagram size that may be sent, for a particular combination of IP
          source and destination addresses...".</t>

          <t hangText="EMTU_R:">The Effective MTU for receiving (EMTU_R) is
          designated in <xref target="RFC1122"></xref> as the largest datagram
          size that can be reassembled by EMTU_R ("Effective MTU to
          receive").</t>

          <t hangText="Link:">A communication facility or medium over which
          nodes can communicate at the link layer, i.e., a layer below the IP
          layer. Examples are Ethernet LANs and Internet (or higher) layer and
          tunnels.</t>

          <t hangText="Link MTU:">The Maximum Transmission Unit (MTU) is the
          size in bytes of the largest IP packet, including the IP header and
          payload, that can be transmitted over a link. Note that this could
          more properly be called the IP MTU, to be consistent with how other
          standards organizations use the acronym MT. This includes the IP
          header, but excludes link layer headers and other framing that is
          not part of IP or the IP payload. Other standards organizations
          generally define link MTU to include the link layer headers.</t>

          <t hangText="MPS:">The Maximum Packet Size (MPS) is the largest size
          of application data block that can be sent unfragmented across a
          path. In DPLPMTUD this quantity is derived from PLPMTU by taking
          into consideration the size of the application and lower protocol
          layer headers.</t>

          <t hangText="Packet:">An IP header plus the IP payload.</t>

          <t hangText="Packetization Layer (PL):">The layer of the network
          stack that places data into packets and performs transport protocol
          functions.</t>

          <t hangText="Path:">The set of link and routers traversed by a
          packet between a source node and a destination node by a particular
          flow.</t>

          <t hangText="Path MTU (PMTU):">The minimum of the Link MTU of all
          the links forming a path between a source node and a destination
          node.</t>

          <t hangText="PLPMTU:">The estimate of the actual PMTU provided by
          the DPLPMTUD algorithm.</t>

          <t hangText="PLPMTUD:">Packetization Layer Path MTU Discovery, the
          method described in this document for datagram PLs, which is an
          extension to Classical PMTU Discovery.</t>

          <t hangText="Probe packet:">A datagram sent with a purposely chosen
          size (typically larger than the current PLPMTU) to detect if packets
          of this size can be successfully sent end-toend across the network
          path.</t>
        </list></t>
    </section>

    <section anchor="Requirements"
             title="Features Required to Provide Datagram PLPMTUD">
      <t>TCP PLPMTUD has been defined using standard TCP protocol mechanisms.
      All of the requirements in <xref target="RFC4821"></xref> also apply to
      use of the technique with a datagram PL. Unlike TCP, some datagram PLs
      require additional mechanisms to implement PLPMTUD.</t>

      <t>There are eight requirements for performing the datagram PLPMTUD
      method described in this specification: <list style="numbers">
          <t>PMTU parameters: A DPLPMTUD sender is RECOMMENDED to provide
          information about the maximum size of packet that can be transmitted
          by the sender on the local link (the local Link MTU). It MAY utilize
          similar information about the receiver when this is supplied (note
          this could be less than EMTU_R). This avoids implementations trying
          to send probe packets that can not be transmited by the local link.
          Too high a value may reduce the efficiency of the search algorithm.
          Some applications also have a maximum transport protocol data unit
          (PDU) size, in which case there is no benefit from probing for a
          size larger than this (unless a transport allows multiplexing
          multiple applications PDUs into the same datagram).</t>

          <t>PLPMTU: A datagram application MUST be able to choose the size of
          datagrams sent to the network, up to the PLPMTU, or a smaller value
          (such as the MPS) derived from this. This value is managed by the
          DPLPMTUD method. The PLPMTU (specified as the effective PMTU in
          Section 1 of <xref target="RFC1191"></xref>) is equivalent to the
          EMTU_S (specified in <xref target="RFC1122"></xref>).</t>

          <t>Probe packets: On request, a PLPMTUD sender is REQUIRED to be
          able to transmit a packet larger than the PLMPMTU. This can be uses
          to send a probe packet. In IPv4, a probe packet MUST be sent with
          the Don't Fragment (DF) bit set in the IP header, and without
          network layer endpoint fragmentation. In IPv6, a probe packet is
          always sent without source fragmentation (as specified in section
          5.4 of <xref target="RFC8201"></xref>).</t>

          <t>Processing PTB messages: A DPLPMTUD sender MAY optionally utilize
          PTB messages received from the network layer to help identify when a
          path does not support the current size of packet probe. Any received
          PTB message MUST be verified before it is used to update the PLPMTU
          discovery information <xref target="RFC8201"></xref>. This
          verification confirms that the PTB message was sent in response to a
          packet originating by the sender, and needs to be performed before
          the PLPMTU discovery method reacts to the PTB message. When the
          router link MTU is indicated in the PTB message this MAY be used by
          DPLPMTUD to reduce the probe size but MUST NOT be used to increase
          the PLPMTU (<xref target="RFC8201"></xref>). Verification SHOULD
          utilise information that can not be simply determined by an off-path
          attacker, for example, by checking the value of a protocol header
          field known only to the two PL endpoints. (Some datagram
          applications use well-known source and destination ports and
          therefore this check needs to rely on other information.)</t>

          <t>Reception feedback: The destination PL endpoint is REQUIRED to
          provide a feedback method that indicates to the DPLPMTUD sender when
          a probe packet has been received by the destination PL endpoint. The
          local PL endpoint at the sending node is REQUIRED to pass this
          feedback to the sender-side DPLPMTUD method.</t>

          <t anchor="CC">Probing and congestion control: The isolated loss of
          a probe packet SHOULD NOT be treated as an indication of congestion
          and its loss SHOULD NOT directly trigger a congestion control
          reaction <xref target="RFC4821"></xref>.</t>

          <t>Probe loss recovery: If the data block carried by a probe message
          needs to be sent reliably, the PL (or layers above) MUST arrange
          retransmission/repair of any resulting loss. This method MUST be
          robust in the case where probe packets are lost due to other reasons
          (including link transmission error, congestion). The DPLPMTUD method
          treats isolated loss of a probe packet (with or without an PTB
          message) as a potential indication of a PMTU limit on the path, but
          not as an indictaion of congestion <xref target="CC"></xref>.</t>

          <t>Shared PLPMTU state: The PLPMTU value could also be stored with
          the corresponding entry in the destination cache and used by other
          PL instances. The specification of PLPMTUD <xref
          target="RFC4821"></xref> states: "If PLPMTUD updates the MTU for a
          particular path, all Packetization Layer sessions that share the
          path representation (as described in Section 5.2 of <xref
          target="RFC4821"></xref>) SHOULD be notified to make use of the new
          MTU and make the required congestion control adjustments". Such
          methods need to be robust to the wide variety of underlying network
          forwarding behaviours, PLPMTU adjustments based on shared PLPMTU
          values should be incorporated in the search algorithms. Section 5.2
          of <xref target="RFC8201"></xref> provides guidance on the caching
          of PMTU information and also the relation to IPv6 flow labels.</t>
        </list>In addition, the following principles are stated for design of
      a DPLPMTUD method:</t>

      <t><list style="symbols">
          <t>MPS: A method MUST signal appropriate MPS to the higher layer
          using the PL. This may change following a change to the path. The
          method SHOULD avoid forcing an application to use an arbitrary small
          MPS (PLPMTU) for transmission while the method is searching for the
          currently supported PLPMTU. Datagram PLs do not necessarily support
          fragmentation of PDUs larger than the PLPMTU. A reduced MPS can
          adversely impact the performance of a datagram application.</t>

          <t>Path validation: A method MUST be robust to path changes that
          could have occurred since the path characteristics were last
          confirmed, and to the possibility of inconsistent path information
          being received.</t>

          <t>Datagram reordering: A method MUST be robust to the possibility
          that a flow encounters reordering, or has the traffic (including
          probe packets) is divided over more than one network path.</t>

          <t>When to probe: A method SHOULD determine whether the path
          capacity has increased since it last measured the path. This
          determines when the path should again be probed.</t>
        </list></t>

      <section title="PLPMTU Probe Packets">
        <t>The DPLPMTUD method relies upon the PL sender being able to
        generate probe messages with a specific size. TCP is able to generate
        these probe packets by choosing to appropriately segment data being
        sent <xref target="RFC4821"></xref>.</t>

        <t>In contrast, a datagram PL that needs to construct a probe packet
        has to either request an application to send a data block that is
        larger than that generated by an application, or to utilise padding
        functions to extend a datagram beyond the size of the application data
        block. Protocols that permit exchange of control messages (without an
        application data block) could alternatively prefer to generate a probe
        packet by extending a control message with padding data.</t>

        <t>When the method fails to validate the PLPMTU, it may be required to
        send a probe packet with a size less than the size of the data block
        generated by an application. In this case, the PL could provide a way
        to fragment a datagram at the PL, or could instead utilise a control
        packet with padding.</t>

        <t>A receiver needs to be able to distinguish an in-band data block
        from any added padding. This is needed to ensure that any added
        padding is not passed on to an application at the receiver.</t>

        <t>This results in three possible ways that a sender can create a
        probe packet listed in order of preference:<list style="hanging">
            <t hangText="Probing using padding data:">A probe packet that
            contains only control information together with any padding needed
            to inflate the packet to the size required for the probe packet.
            Since these probe packets do not carry an application-supplied
            data block,they do not typically require retransmission, although
            they do still consume network capacity and incur endpoint
            processing.</t>

            <t hangText="Probing using appication data and padding data:">A
            probe packet that contains a data block supplied by an application
            that is combined with padding to inflate the length of the
            datagram to the size required for the probe packet. If the
            application/transport needs protection from the loss of this probe
            packet, the application/transport may perform transport-layer
            retransmission/repair of the data block (e.g., by retransmission
            after loss is detected or by duplicating the data block in a
            datagram without the padding data).</t>

            <t hangText="Probing using appication data:">A probe packet that
            contains a data block supplied by an application that matches the
            size required for the probe packet. This method requests the
            application to issue a data block of the desired probe size. If
            the application/transport needs protection from the loss of an
            unsuccessful probe packet, the application/transport needs then to
            perform transport-layer retransmission/repair of the data block
            (e.g., by retransmission after loss is detected).</t>
          </list>A PL that uses a probe packet carrying an application data
        block, could need to retransmit this application data block if the
        probe fails. This could need the PL to re-fragment the data block to a
        smaller packet size that is expected to traverse the end-to-end path
        (which could utilise network-layer or PL fragmentation when these are
        available).</t>

        <t>DLPMTUD MAY choose to use only one of these methods to simplify the
        implementation.</t>
      </section>

      <section title="Validation of Probe Packet Size">
        <t>The PL needs a method to determine when probe packets have been
        successfully received end-to-end across a network path.</t>

        <t>Transport protocols can include end-to-end methods that detect and
        report reception of specific datagrams that they send (e.g., DCCP and
        SCTP provide keep-alive/heartbeat features). When supported, this
        mechanism SHOULD also be used by DPLPMTUD to acknowledge reception of
        a probe packet.</t>

        <t>A PL that does not acknowledge data reception (e.g., UDP and
        UDP-Lite) is unable to detect when the packets that it sends are
        discarded because their size is greater than the actual PMTU. These
        PLs need to either rely on an application protocol to detect this
        loss, or make use of an additional transport method such as
        UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref>. In
        addition, they might need to send reachability probes (e.g.,
        periodically solicit a response from the destination) to determine
        whether the last successfully probed PLPMTU is still supported by the
        network path.</t>

        <t>Section <xref target="Spec"></xref> specifies this function for a
        set of IETF-specified protocols.</t>
      </section>

      <section title="Reducing the PLPMTU: Confirming Path Characteristics">
        <t>If the DPLPMTUD method detects that a packet with the PLPMTU size
        is no supported by the network path, then the DLPMTUD method needs to
        validate the PLPMTU. This can happen when a validated PTB message is
        received, or another event that indicates the network path no longer
        sustains this packet size, such as a loss report from the PL</t>

        <t>All implementations of DPLPMTUD are REQUIRED to provide support
        that reduces the PLPMTU when the actual PMTU supported by a network
        path is less than the PLPMTU.</t>
      </section>

      <section title="Increasing the PLPMTU: Supporting Path Changes">
        <t>An implementation that only reduces the PLPMTU to a suitable size
        is sufficient to ensure reliable operation, but may be very
        inefficient when the actual PMTU changes or when the method (for
        whatever reason) makes a suboptimal choice for the PLPMTU.</t>

        <t>A full implementation of the DPLPMTUD method is RECOMMENDED to
        provide a way for the sending PL endpoint to detect when the PLPMTU is
        smaller than the actual PMTU size. This allows the sender to increase
        the PLPMTU following a change in the characteristics of the path, such
        as when a link is reconfigured with a larger MTU, or when there is a
        change in the set of links traversed by an end-to-end flow (e.g. after
        a routing or fail-over decision).</t>
      </section>

      <section anchor="robustness"
               title="Robustness to inconsistent Path information">
        <t>The decision to increase the PLPMTU needs to be robust to the
        possibility that information learned about the path is inconsistent
        (this could happen when probe packets are lost due to other reasons,
        or some of the packets in a flow are forwarded along a portion of the
        path that supports a different PMTU).</t>

        <t>Frequent path changes could occur due to unexpected "flapping" -
        where some packets from a flow pass along one path, but other packets
        follow a different path with different properties. DPLPMTUD can be
        made robust to these anomalies by introducing hysteresis into the
        decision to increase the Maximum Packet Size.</t>

        <t>XXX A future revision of this section will include recommend
        appropriate methods to provide robustness. XXX</t>
      </section>
    </section>

    <section anchor="Spec" title="Datagram Packetization Layer PMTUD">
      <t>This section specifies Datagram PLPMTUD (DPLPMTUD). This method can
      be introduced at various points in the IP protocol stack, to discover
      the PLPMTU so that the application can use an MPS appropriate to the
      current network path.</t>

<t><figure anchor="fig-plpmtudimplement" title="Places where DPLPMTUD can be implemented">
          <artwork><![CDATA[
            +-----------+
            |   APP*    |
            +-----------+
           __||  |   | |___
       ___/   |  |   |     \
    __/       |  |   |      \__
+------++-----+ | +------+    |
| QUIC*||UDPO*| | | SCTP*|    |
+------++-----+ | +-+-----+    |
              +-----+        +------+
              | UDP |        | SCTP*|
              +-----+        +------+
                 |              |
          +----------------------+
          |  Network Interface   |
          +----------------------+
]]></artwork>
        </figure></t>

      <t>The central idea of DPLPMTUD is probing by a sender. Probe packets of
      increasing size are sent to find out the maximum size of user message
      that is completely transferred across the network path from the sender
      to the destination.</t>

     <t><xref target="fig-mps"></xref> describes the relationship
     between the different packet sizes used by the DPLPMTUD algorithm.</t>

<t><figure anchor="fig-mps" title="Relationships between packet sizes">
          <artwork><![CDATA[

     BASE_MTU                                               MAX_MTU
       <------------------------------------------------------>
                         |    |        |
                         V    |        |
                         MPS  V        |
                           PROBED_SIZE V
                                    PLPMTU
]]></artwork>
        </figure></t>
        <t> XXX I have a note to create this diagram, but I am not sure if
        these relationships are correct at all XXX </t>

      <section title="PROBE_SEARCH: Probing for a larger PLPMTU">
        <t>The DPLPMTUD method utilises probe packets to confirm that a packet
        of size PROBE_SIZE can traverse the network path. The PROBE_COUNT is
        initialised to zero when a probe packet is first sent with a
        particular size.</t>

        <t>A timer is used to trigger the generation of probe packets. The
        probe_timer is started each time a probe packet is sent to the
        destination and is cancelled when receipt of the probe packet is
        acknowledged. THE PROBE_SIZE is confirmed, and this value is then
        assignmed to PLPMTU. The DPLPMTUD method may send subsequent probes of
        an increasing size. Increasing probes follows a search strategy as
        discussed in <xref target="probe-algorithm"></xref>.</t>

        <t>Each time the probe_timer expires, the PROBE_COUNT is incremented,
        teh probe_timer is reinitialised, and a probe packet of the same size
        is retransmitted.</t>

        <t>The maximum number of retransmissions for a PROBE_SIZE is
        configured (MAX_PROBES). If the value of the PROBE_COUNT reaches
        MAX_PROBES, probing will stop.</t>
      </section>

      <section title="The PROBE_DONE state">
        <t>When the PL sender complete probing for a larger PLPMTU, it enters
        the PROBE_DONE state. This starts the PMTU_RAISE_TIMER. While this
        running, the PLPMTU remains at the value set in the last succesful
        probe packet.</t>

        <t>If the PL is designed in a way that is unable to verify
        reachability to the destination endpoint after probing has completed,
        the method uses a REACHABILITY_TIMER to periodically repeat a probe
        packet for the current PLPMTU size, while the PMTU_RAISE_TIMER is
        running. If the REACHABILITY_TIMER expires, the method exits the
        PROBE_DONE state. The done state is also exited when a verified PTB
        message is received.</t>

        <t>If the PMTU_RAISE_TIMER expires, the PL sender also exits the
        PROBE_DONE state, but in this case resumes probing from the size of
        the PLPMTU.</t>
      </section>

      <section title="Verification and Use of PTB Messages">
        <t>This section describes processing for both IPv4 ICMP Unreachable
        messages (type 3) and ICMPv6 packet too big messages.</t>

        <t>A node that receives a PTB message from a router or middlebox, MUST
        verify the PTB message. The node checks the protocol information in
        the quoted payload to verify that the message originated from the
        sending node. The node also checks that the reported MTU size is less
        than the size used by packet probes. PTB messages are discarded if
        they fail to pass these checks, or where there is insufficient ICMP
        payload to perform these checks. The checks are intended to provide
        protection from packets that originate from a node that is not on the
        network path or a node that attempts to report a larger MTU than the
        current probe size.</t>

        <t>PTB messages that have been verified can be utilised by the
        DPLPMTUD algorithm. A method that utilises these PTB messages can
        improve performance compared to one that relies solely on probing.</t>
      </section>

      <section title="Timers">
        <t>The method in the previous subsections utilises three timers:<list
            style="hanging">
            <t hangText="PROBE_TIMER:">Configured to expire after a period
            longer than the maximum time to receive an acknowledgment to a
            probe packet. This value MUST be larger than 1 second, and SHOULD
            be larger than 15 seconds. Guidance on selection of the timer
            value are provide in section 3.1.1 of the UDP Usage Guidelines
            <xref target="RFC8085"></xref>.</t>

            <t hangText="">If the PL has an RTT estimate and timely
            acknowedgements the PROBE_TIMER can be derrived from the PL RTT
            estimate.</t>

            <t hangText="PMTU_RAISE_TIMER:">Configured to the period a sender
            ought to continue use the current PLPMTU, after which it
            re-commences probing for a higher PMTU. This timer has a period of
            600 secs, as recommended by DPLPMTUD <xref
            target="RFC4821"></xref>.</t>

            <t hangText="REACHABILITY_TIMER:">Configured to the period a
            sender ought to wait before confirming the current PLPMTU is still
            supported. This is less than the PMTU_RAISE_TIMER and used to
            decrease the PLPMTU (e.g. when a black hole is encountered).</t>

            <t hangText="">DPLPMTUD ought to suspend reachability probes when
            no application data has been sent since the previous probe packet.
            Guidance on selection of the timer value are provide in section
            3.1.1 of the UDP Usage Guidelines<xref target="RFC8085"></xref>.
            DPLPMTUD ought to be suspended or only sent in conjuction with out
            traffic during periods of dormancy. This verification needs to be
            frequent enough when data is flowing that you do not black hole
            extensive amounts of traffic</t>
          </list></t>

        <t>An implementation could implement the various timers using a single
        timer process.</t>
      </section>

      <section title="Constants">
        <t>The following constants are defined:</t>

        <t><list style="hanging">
            <t hangText="MAX_PROBES:">The maximum value of the
            PROBE_ERROR_COUNTER. The default value of MAX_PROBES is 10.</t>

            <t hangText="MIN_PMTU:">The smallest allowed probe packet size.
            For IPv6, this value is 1280 bytes, as specified in <xref
            target="RFC2460"></xref>. For IPv4, the minimum value is 68 bytes.
            (An IPv4 routed is required to be able to forward a datagram of 68
            octets without further fragmentation. This is the combined size of
            an IPv4 header and the minimum fragment size of 8 octets.)</t>

            <t hangText="BASE_PMTU:">The BASE_PMTU is a considered a size that
            ought to work in most cases. The size is equal to or larger than
            the minimum permitted and smaller than the maximum allowed. In the
            case of IPv6, this value is 1280 bytes <xref
            target="RFC2460"></xref>. When using IPv4, a size of 1200 bytes is
            RECOMMENDED.</t>

            <t hangText="MAX_PMTU:">The MAX_PMTU is the largest size of PLPMTU
            that is probed. This has to be less than or equal to the minimum
            of the local MTU of the outgoing interface and the destination
            PLMTU for receiving. An application or PL may reduce this when it
            knows there is no need to send packets above a specific size.</t>
          </list></t>
      </section>

      <section title="Variables">
        <t>This method utilises a set of variables: <list style="hanging">
            <t hangText="PROBE_TIMER:">Configured to expire after a period
            longer than the maximum time to receive an acknowledgment to a
            probe packet. This value MUST be larger than 1 second, and SHOULD
            be larger than 15 seconds. Guidance on selection of the timer
            value are provide in section 3.1.1 of the UDP Usage Guidelines
            <xref target="RFC8085"></xref>.</t>

            <t hangText="">PL with RTT estimates may use values smaller than 1
            seconded derrived from their RTT estimate to speed up detection of
            connectivity issues on the path.</t>

            <t hangText="PROBED_SIZE:">The PROBED_SIZE is the size of the
            current probe packet. This is a tentative value for the PLPMTU,
            which is awaiting confirmation by an acknowledgment.</t>

            <t hangText="PROBE_COUNT:">This is a count of the number of
            unsuccessful probe packets that have been sent with size
            PROBED_SIZE. The value is initialised to zero when a particular
            size of PROBED_SIZE is first attempted.</t>

            <t hangText="PTB_SIZE:">The PTB_Size is value returned by a
            verified PTB message indicating the local MTU size of a router
            along the path.</t>
          </list></t>
      </section>

      <section anchor="probe-algorithm" title="Selecting PROBED_SIZE">
        <t>Implementations discover the search range by validating the minimum
        path MTU and then using the probe method to select a PROBED_SIZE less
        than or equal to the maximum PMTU_MAX. Where PMTU_MAX is the minimum
        of the local link MTU and EMTU_R (learned from the remote endpoint).
        The PMTU_MAX MAY be constrained by an application that has a maximum
        to the size of datagrams it wishes to send.</t>

        <t>Implementations use a search algorithm to choose probe sizes within
        the search range.</t>

        <t>xxx A future version of this section will detail example methods
        for selecting probe size values, but does not plan to mandate a single
        method. xxx</t>

        <t>Implementations MAY optimizse the search procedure by selecting
        step sizes from a table of common PMTU sizes.</t>

        <t>Implementations SHOULD select probe sizes to maximise the gain in
        PLPMTU each search step. Implementations ought to take into
        consideration useful probe size steps and a minimum useful gain in
        PLPMTU.</t>
      </section>

      <section title="Black Hole Detection">
        <t>The DPLPMTUD method can be used to detect paths that fail to support
        a packet size, but return no PTB message. Black Hole detection
        functions detect such cases and responds by reducing the PLPMTU,
        allowing the endpoint to inform the application of the reduced MPS and
        accordingly send smaller packets. Black Hole detection is triggered by
        the reachability function using the absence of positive
        acknowledgements to PROBE packets to indicate that the current PLPMU is
        no longer valid.</t>

        <t>
        Once a PL has a PLPMTU greater than the BASE_MTU the reachability
        mechanism sends periodic PROBE messages at the PROBED_SIZE to
        revalidate the PLPMTU. If the number of PROBE messages send without
        receiving an acknowledgement (PROBE_COUNT) is greater than the
        MAX_PROBES then the PLPMTU detects this as a black hole and reverts to
        using the BASE_MTU.
        </t>

        <t>
        A stand alone black hole detection mechanism is depicted in
        <xref target="fig-blackhole"></xref>.
        </t>

        <t>
<figure anchor="fig-blackhole" title="State machine for detecting black holes">
<artwork align="center"><![CDATA[
                        +------------+
PROBE_COUNT >=       ---| PROBE_BASE |____
  MAX_PROBES   -----/   +------------+   |
           V--/               ^    ^     | PROBE_COUNT < MAX_PROBES
    +------------+            |    |_____|
    | PROBE_ERROR|            |
    +------------+            | PROBE_COUNT >= MAX_PROBES
                              |
                        +------------+
                        | PROBE_DONE |____
                        +------------+   |
                                   ^     | PROBE_COUNT < MAX_PROBES
                                   |_____|
]]></artwork>
        </figure>
        </t>
        <t> XXX gorry please check. I have tried to model both hitting a black
        hole when above BASE and hitting a black hole at BASE. XXX </t>
      </section>

      <section anchor="States" title="State Machine">
        <t>A state machine for DPLPMTUD is depicted in <xref
        target="fig-states"></xref>. If multihoming is supported, a state
        machine is needed for each active path.</t>

        <figure anchor="fig-states" title="State machine for Datagram PLPMTUD">
          <artwork align="center"><![CDATA[

                                      PROBE_TIMER expiry
                                   (PROBE_COUNT = MAX_PROBES)
                        +-------------+                +--------------+
                     =->| PROBE_START |--------------->|PROBE_DISABLED|
  PROBE_TIMER expiry |  +-------------+                +--------------+
 (PROBE_COUNT =      |     |       |  
         MAX_PROBES) -------       |  Connectivity confirmed
                                   v
                  ----------- +------------+ -- PROBE_TIMER expiry
MAX_PMTU acked or |           | PROBE_BASE |  | (PROBE_COUNT < 
PTB (>= BASE_PMTU)|    -----> +------------+ <-             MAX_PROBES)
  ----------------     |          /\   |  |
  |                    |           |   |  | PTB
  |    PMTU_RAISE_TIMER|           |   |  | (PTB_SIZE < BASE_PMTU)
  |    or reachability |           |   |  |        or
  |     (PROBE_COUNT   |           |   |  |    PROBE_TIMER expiry
  |      = MAX_PROBES) |           |   |  | (PROBE_COUNT = MAX_PROBES)
  |        -------------           |   |   \      
  |        |                   PTB |   |    \  
  |        |        (< PROBED_SIZE)|   |     \ 
  |        |                       |   |      ----------------
  |        |                       |   |                     |
  |        |                       |   | Probe               |
  |        |                       |   | acked               |
  v        |                       |   v                     v
+------------+                +--------------+  Probe +-------------+
| PROBE_DONE |<-------------- | PROBE_SEARCH |<-------| PROBE_ERROR |
+------------+ MAX_PMTU acked +--------------+  acked +-------------+
 /\    |             or            /\      |
  |    |      PROBE_TIMER expiry    |      |
  |    |(PROBE_COUNT = MAX_PROBES)  |      | 
  |    |                            |      |                 
  ------                            --------
Reachability probe acked      PROBE_TIMER expiry                     
 or PROBE_TIMER expiry      (PROBE_COUNT < MAX_PROBES)
(PROBE_COUNT < MAX_PROBES)            or
                                Probe acked

]]></artwork>
        </figure>

        <t></t>

        <t>XXX A future version of this document will update the state machine
        to describe handling of validated PTB messages. XXX</t>

        <t>The following states are defined to reflect the probing
        process:</t>

        <t><list style="hanging">
            <t hangText="PROBE_START:">The PROBE_START state is the initial
            state before probing has started. PLPMTUD is not performed in this
            state. The state transitions to PROBE_BASE, when a path has been
            confirmed, i.e. when a sent packet has been acknowledged on this
            path. Any transport method may be used to exit PROBE_BASE as long
            as the send packet is acknowledge by the other side. The PLPMTU is
            set to the BASE_PMTU size. Probing ought to start immediately
            after connection setup to prevent the prevent the loss of user
            data.</t>

            <t hangText="PROBE_BASE:">The PROBE_BASE state is the starting
            point for probing with datagram PLPMTUD. It is used to confirm
            whether the BASE_PMTU size is supported by the network path. On
            entry, the PROBED_SIZE is set to the BASE_PMTU size and the
            PROBE_COUNT is set to zero. A probe packet is sent, and the
            PROBE_TIMER is started. The state is left when the PROBE_COUNT
            reaches MAX_PROBES; a PTB message is verified, or a probe packet
            is acknowledged.</t>

            <t hangText="PROBE_SEARCH:">The PROBE_SEARCH state is the main
            probing state. This state is entered either when probing for the
            BASE_PMTU was successful or when there is a successful
            reachability test in the PROBE_ERROR state. On entry, the PLPMTU
            is set to the last acknowledged PROBED_SIZE.</t>

            <t hangText="">The PROBE_COUNT is set to zero when the first probe
            packet is sent for each probe size. Each time a probe packet is
            acknowledged, the PLPMTU is set to the PROBED_SIZE, and then the
            PROBED_SIZE is increased.</t>

            <t hangText="">When a probe packet is sent and not acknowledged
            within the period of the PROBE_TIMER, the PROBE_COUNT is
            incremented and the probe packet is retransmitted. The state is
            exited when the PROBE_COUNT reaches MAX_PROBES; a PTB message is
            verified; or a probe of size PMTU_MAX is acknowledged.</t>

            <t hangText="PROBE_ERROR:">The PROBE_ERROR state represents the
            case where the network path is not known to support an PLPMTU of
            at least the BASE_PMTU size. It is entered when either a probe of
            size BASE_PMTU has not been acknowledged or a verified PTB message
            indicates a smaller link MTU than the BASE_PMTU. On entry, the
            PROBE_COUNT is set to zero and the PROBED_SIZE is set to the
            MIN_PMTU size, and the PLPMTU is reset to MIN_PMTU size. In this
            state, a probe packet is sent, and the PROBE_TIMER is started. The
            state transitions to the PROBE_SEARCH state when a probe packet is
            acknowledged.</t>

            <t hangText="PROBE_DONE:">The PROBE_DONE state indicates a
            successful end to a probing phase. DPLPMTUD remains in this state
            until either the PMTU_RAISE_TIMER expires or a received PTB
            message is verified.</t>

            <t hangText="">When PLPMTUD uses an unacknowledged PL and is in
            the PROBE_DONE state, a REACHABILITY_TIMER periodically resets the
            PROBE_COUNT and schedules a probe packet with the size of the
            PLPMTU. If the probe packet fails to be acknowledged after
            MAX_PROBES attempts, the method enters the PROBE_BASE state. When
            used with an acknowledged PL (e.g., SCTP), DPLPMTUD SHOULD NOT
            continue to probe in this state.</t>

            <t hangText="PROBE_DISABLED:">The PROBE_DISABLED state indicates
            that connectivity could not be established. DPLPMTUD MUST NOT
            probe in this state.</t>
          </list><xref target="StateChanges"></xref> contains an informative
        description of key events.</t>
      </section>

      <section anchor="SimpleStates" title="Simplified State Machine">
        <t>A simplified state machine for DPLPMTUD is depicted in <xref
        target="fig-simplestates"></xref>. If multihoming is supported, a state
        machine is needed for each active path.</t>
        <t>
<figure anchor="fig-simplestates" title="Simplified State machine for Datagram PLPMTUD">
<artwork align="center"><![CDATA[
                                PROBE_COUNT >= MAX_PROBES

                         +------------+           +------------+
   PROBE_ACK         ----| PROBE_BASE |---------->| PROBE_ERROR|
   (MIN_MTU)  ------/    +------------+           +------------+
          V--/                 ^
    +------------+             |
    |PROBE_SEARCH|             |
    +------------+             | PROBE_COUNT >= MAX_PROBES
          |---                 |
              \------    +------------+
     PROBED_SIZE ==  \-->| PROBE_DONE |____
        MAX_MTU          +------------+   |
   OR black hole                    ^     | PROBE_COUNT < MAX_PROBES
                                    |_____|
]]></artwork>
        </figure>
        </t>
        <t> XXX gorry please check. I have tried to model a simple search using
        only the reachability timer XXX </t>
      </section>
    </section>

    <section anchor="protocol_specific_methods"
             title="Specification of Protocol-Specific Methods">
      <t>This section specifies protocol-specific details for datagram PLPMTUD
      for IETF-specified transports.</t>

      <t>The first subsection provides guidance on how to implement the
      DPLPMTUD method as a part of an application using UDP or UDP-Lite. The
      guidance also applies to other datagram services that do not include a
      specific transport protocol (such as a tunnel encapsulation). The
      following subsection describe how DPLPMTUD can be implemented as a part
      of the transport service, allowing applications using the service to
      benefit from discovery of the PLPMTU without themselves needing to
      implement this method.</t>

      <section title="Application support for DPLPMTUD with UDP or UDP-Lite">
        <t>The current specifications of UDP <xref target="RFC0768"></xref>
        and UDP-Lite <xref target="RFC3828"></xref> do not define a method in
        the RFC-series that supports PLPMTUD. In particular, the UDP transport
        does not provide the transport layer features needed to implement
        datagram PLPMTUD.</t>

        <t>The DPLPMTUD method can be implemented as a part of an application
        built directly or indirectly on UDP or UDP-Lite, but relies on
        higher-layer protocol features to implement the method <xref
        target="RFC8085"></xref>.</t>

        <t>Some primitives used by DPLPMTUD might not be available via the
        Datagram API (e.g., the ability to access the PLPMTU cache, or
        interpret received ICMP PTB messages).</t>

        <t>In addition, it is desirable that PMTU discovery is not performed
        by multiple protocol layers. An application SHOULD avoid implementing
        DPLPMTUD when the underlying transport system provides this
        capability. Using a common method for manging the PLPMTU has benefits,
        both in the ability to share state between different processes and
        opportunities to coordinate probing.</t>

        <section anchor="UDP-REQ" title="Application Request ">
          <t>An application needs an application-layer protocol mechanism
          (such as a message acknowledgement method) that solicits a response
          from a destination endpoint. The method SHOULD allow the sender to
          check the value returned in the response to provide additional
          protection from off-path insertion of data <xref
          target="RFC8085"></xref>, suitable methods include a parameter known
          only to the two endpoints, such as a session ID or initialised
          sequence number.</t>
        </section>

        <section anchor="UDP-Probe" title="Application Response ">
          <t>An application needs an application-layer protocol mechanism to
          communicate the response from the destination endpoint. This
          response may indicate successful reception of the probe across the
          path, but could also indicate that some (or all packets) have failed
          to reach the destination.</t>
        </section>

        <section anchor="UDP-probing"
                 title="Sending Application Probe Packets">
          <t>A probe packet that may carry an application data block, but the
          successful transmission of this data is at risk when used for
          probing. Some applications may prefer to use a probe packet that
          does not carry an application data block to avoid disruption to
          normal data transfer.</t>
        </section>

        <section title="Validating the Path ">
          <t>An application that does not have other higher-layer information
          confirming correct delivery of datagrams SHOULD implement the
          REACHABILITY_TIMER to periodically send probe packets while in the
          PROBE_DONE state.</t>
        </section>

        <section anchor="udpopt_ptb_handling" title="Handling of PTB Messages">
          <t>An application that is able and wishes to receive PTB messages
          MUST perform ICMP verification as specified in Section 5.2 of <xref
          target="RFC8085"></xref>. This requires that the application
          verifies each received PTB messages to verify these are received in
          response to transmitted traffic and that the reported link MTU is
          less than the current probe size. A verified PTB message MAY be used
          as input to the DPLPMTUD algorithm, but MUST NOT be used directly to
          set the PLPMTU.</t>
        </section>
      </section>

      <section anchor="UDPOPT-PLPMTUD" title="DPLPMTUD with UDP Options">
        <t>UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref> can
        supply the additional functionality required to implement DPLPMTUD
        within the UDP transport service. This avoids the need for
        applications to implement the DPLPMTUD method.</t>

        <t>This enables padding to be added to UDP datagrams and can be used
        to provide feedback acknowledgement of received probe packets.</t>

        <t>The specification also defines two UDP Options to support
        DPLMTUD.</t>

        <t>Section 5.6 of <xref target="I-D.ietf-tsvwg-udp-options"></xref>
        defines the MSS option which allows the local sender to indicate the
        EMTU_R to the peer. This option can be used to initialise PMTU_MAX. An
        application wishing to avoid the effects of MSS-Clamping (where a
        middlebox changes the advertised TCP maximum sending size) ought to
        use a cryptographic method to encrypt this parameter.</t>

        <section anchor="UDPOPT-ECHOREQ" title="UDP Request Option">
          <t>The Request Option allows a sending endpoint to solicit a
          response from a destination endpoint.</t>

          <t>The Request Option carries a four byte token set by the sender.
          This token can be set to a value that is likely to be known only to
          the sender (and becomes known to nodes along the end-to-end path).
          The sender can then check the value returned in the response to
          provide additional protection from off-path insertion of data <xref
          target="RFC8085"></xref>.</t>

          <figure anchor="fig-echoreq" title="UDP ECHOREQ Option Format">
            <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=9  | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
          </figure>
        </section>

        <section anchor="UDPOPT-ECHORES" title="UDP Response Option">
          <t>The Response Option is generated by the PL in response to
          reception of a previously received Echo Request. The Token field
          associates the response with the Token value carried in the most
          recently-received Echo Request. The rate of generation of UDP
          packets carrying a Response Option MAY be rate-limited.</t>

          <figure anchor="fig-echores" title="UDP ECHORES Option Format">
            <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=10 | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
          </figure>
        </section>
      </section>

      <section title="DPLPMTUD for SCTP">
        <t>Section 10.2 of <xref target="RFC4821"></xref> specifies a
        recommended PLPMTUD probing method for SCTP. It recommends the use of
        the PAD chunk, defined in <xref target="RFC4820"></xref> to be
        attached to a minimum length HEARTBEAT chunk to build a probe packet.
        This enables probing without affecting the transfer of user messages
        and without interfering with congestion control. This is preferred to
        using DATA chunks (with padding as required) as path probes.</t>

        <t>XXX Future versions of this document might define a parameter
        contained in the INIT and INIT ACK chunk to indicate the remote peer
        MTU to the local peer. However, multihoming makes this a bit complex,
        so it might not be worth doing. XXX</t>

        <section anchor="sctp_over_ip" title="SCTP/IP4 and SCTP/IPv6">
          <t>The base protocol is specified in <xref target="RFC4960"></xref>.
          This provides an acknowledged PL. A sender can therefore enter the
          PROBE_BASE state as soon as connectivity has been confirmed.</t>

          <section anchor="sctp_over_ip_probing"
                   title="Sending SCTP Probe Packets">
            <t>Probe packets consist of an SCTP common header followed by a
            HEARTBEAT chunk and a PAD chunk. The PAD chunk is used to control
            the length of the probe packet. The HEARTBEAT chunk is used to
            trigger the sending of a HEARTBEAT ACK chunk. The reception of the
            HEARTBEAT ACK chunk acknowledges reception of a successful
            probe.</t>

            <t>The HEARTBEAT chunk carries a Heartbeat Information parameter
            which should include, besides the information suggested in <xref
            target="RFC4960"></xref>, the probe size, which is the size of the
            complete datagram. The size of the PAD chunk is therefore computed
            by reducing the probing size by the IPv4 or IPv6 header size, the
            SCTP common header, the HEARTBEAT request and the PAD chunk
            header. The payload of the PAD chunk contains arbitrary data.</t>

            <t>To avoid fragmentation of retransmitted data, probing starts
            right after the handshake, before data is sent. Assuming normal
            behaviour (i.e., the PMTU is smaller than or equal to the
            interface MTU), this process will take a few round trip time
            periods depending on the number of PMTU sizes probed. The
            Heartbeat timer can be used to implement the PROBE_TIMER.</t>
          </section>

          <section title="Validating the Path with SCTP">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_ip_ptb_handling"
                   title="PTB Message Handling by SCTP">
            <t>Normal ICMP verification MUST be performed as specified in
            Appendix C of <xref target="RFC4960"></xref>. This requires that
            the first 8 bytes of the SCTP common header are quoted in the
            payload of the PTB message, which can be the case for ICMPv4 and
            is normally the case for ICMPv6.</t>

            <t>When a PTB message has been verified, the router Link MTU
            indicated in the PTB message SHOULD be used with the DPLPMTUD
            algorithm, providing that the reported Link MTU is less than the
            current probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/UDP">
          <t>The UDP encapsulation of SCTP is specified in <xref
          target="RFC6951"></xref>.</t>

          <section anchor="sctp_over_udp_probing"
                   title="Sending SCTP/UDP Probe Packets">
            <t>Packet probing can be performed as specified in <xref
            target="sctp_over_ip_probing"></xref>. The maximum payload is
            reduced by 8 bytes, which has to be considered when filling the
            PAD chunk.</t>
          </section>

          <section title="Validating the Path with SCTP/UDP ">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_udp_ptb_handling"
                   title="Handling of PTB Messages by SCTP/UDP">
            <t>Normal ICMP verification MUST be performed for PTB messages as
            specified in Appendix C of <xref target="RFC4960"></xref>. This
            requires that the first 8 bytes of the SCTP common header are
            contained in the PTB message, which can be the case for ICMPv4
            (but note the UDP header also consumes a part of the quoted packet
            header) and is normally the case for ICMPv6. When the verification
            is completed, the router Link MTU size indicated in the PTB
            message SHOULD be used with the DPLPMTUD providing that the
            reported link MTU is less than the current probe size.</t>
          </section>
        </section>

        <section title="DPLPMTUD for SCTP/DTLS">
          <t>The Datagram Transport Layer Security (DTLS) encapsulation of
          SCTP is specified in <xref
          target="I-D.ietf-tsvwg-sctp-dtls-encaps"></xref>. It is used for
          data channels in WebRTC implementations.</t>

          <section anchor="sctp_over_dtls_probing"
                   title="Sending SCTP/DTLS Probe Packets">
            <t>Packet probing can be done as specified in <xref
            target="sctp_over_ip_probing"></xref>.</t>
          </section>

          <section title="Validating the Path with SCTP/DTLS">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_dtls_ptb_handling"
                   title="Handling of PTB Messages by SCTP/DTLS">
            <t>It is not possible to perform normal ICMP verification as
            specified in <xref target="RFC4960"></xref>, since even if the
            ICMP message payload contains sufficient information, the
            reflected SCTP common header would be encrypted. Therefore it is
            not possible to process PTB messages at the PL.</t>
          </section>
        </section>
      </section>

      <section title="DPLPMTUD for QUIC">
        <t>Quick UDP Internet Connection (QUIC) <xref
        target="I-D.ietf-quic-transport"></xref> is a UDP-based transport that
        provides reception feedback.</t>

        <t>Section 9.2 of <xref target="I-D.ietf-quic-transport"></xref>
        describes the path considerations when sending QUIC packets. It
        recommends the use of PADDING frames to build the probe packet. This
        enables probing the without affecting the transfer of other QUIC
        frames.</t>

        <t>This provides an acknowledged PL. A sender can therefore enter the
        PROBE_BASE state as soon as connectivity has been confirmed.</t>

        <section title="Sending QUIC Probe Packets">
          <t>A probe packet consists of a QUIC Header and a payload containing
          only PADDING Frames. PADDING Frames are a single octet (0x00) and
          several of these can be used to create a probe packet of size
          PROBED_SIZE. QUIC provides an acknowledged PL. A sender can
          therefore enter the PROBE_BASE state as soon as connectivity has
          been confirmed.</t>

          <t>The current specification of QUIC sets the following:<list
              style="symbols">
              <t>BASE_PMTU: 1200. A QUIC sender needs to pad initial packets
              to 1200 bytes to validate the path can support packets of a
              useful size.</t>

              <t>MIN_PMTU: 1200 bytes. A QUIC sender that determines the PMTU
              has fallen below 1200 bytes MUST immediately stop sending on the
              affected path.</t>
            </list></t>
        </section>

        <section title="Validating the Path with QUIC">
          <t>QUIC provides an acknowledged PL. A sender therefore MUST NOT
          implement the REACHABILITY_TIMER while in the PROBE_DONE state.</t>
        </section>

        <section title="Handling of PTB Messages by QUIC">
          <t>QUIC operates over the UDP transport, and the guidelines on ICMP
          verification as specified in Section 5.2 of <xref
          target="RFC8085"></xref> therefore apply. Although QUIC does not
          currently specify a method for validating ICMP responses, it does
          provide some guidelines to make it harder for an off-path attacker
          to inject ICMP messages.</t>

          <t><list style="symbols">
              <t>Set the IPv4 Don't Fragment (DF) bit on a small proportion of
              packets, so that most invalid ICMP messages arrive when there
              are no DF packets outstanding, and can therefore be identified
              as spurious.</t>

              <t>Store additional information from the IP or UDP headers from
              DF packets (for example, the IP ID or UDP checksum) to further
              authenticate incoming Datagram Too Big messages.</t>

              <t>Any reduction in PMTU due to a report contained in an ICMP
              packet is provisional until QUIC's loss detection algorithm
              determines that the packet is actually lost.</t>
            </list></t>

          <t>XXX The above list was pulled whole from quic-transport - input
          is invited from QUIC contributors. XXX</t>
        </section>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This work was partially funded by the European Union's Horizon 2020
      research and innovation programme under grant agreement No. 644334
      (NEAT). The views expressed are solely those of the author(s).</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

      <t>XXX If new UDP Options are specified in this document, a request to
      IANA will be included here. XXX</t>

      <t>If there are no requirements for IANA, the section will be removed
      during conversion into an RFC by the RFC Editor.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security considerations for the use of UDP and SCTP are provided
      in the references RFCs. Security guidance for applications using UDP is
      provided in the UDP Usage Guidelines <xref target="RFC8085"></xref>.</t>

      <t>There are cases where PTB messages are not delivered due to policy,
      configuration or equipment design (see <xref
      target="Classic-PMTUD"></xref>), this method therefore does not rely
      upon PTB messages being received, but is able to utilise these when they
      are received by the sender. PTB messages could potentially be used to
      cause a node to inappropriately reduce the PLPMTU. A node supporting
      DPLPMTUD MUST therefore appropriately verify the payload of PTB messages
      to ensure these are received in response to transmitted traffic (i.e., a
      reported error condition that corresponds to a datagram actually sent by
      the path layer.</t>

      <t>Parallel forwarding paths may need to be considered. <xref
      target="robustness"></xref> identifies the need for robustness in the
      method when the path information may be inconsistent.</t>

      <t>A node performing DPLPMTUD could experience conflicting information
      about the size of supported probe packets. This could occur when there
      are multiple paths are concurrently in use and these exhibit a different
      PMTU. If not considered, this could result in data being black holed
      when the PLPMTU is larger than the smallest PMTU across the current
      paths.</t>

      <t>An on-path attacker could forge PTB messages to drive down the
      PLPMTU</t>
    </section>
  </middle>

  <back>
    <!-- References split into informative and normative -->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC792;

      &RFC768;

      &RFC1122;

      &RFC1812;

      &RFC2119;

      &RFC2460;

      &RFC3828;

      &RFC8085;

      &RFC4820;

      &RFC4960;

      &RFC6951;

      &RFC8201;

      &I-D.ietf-tsvwg-udp-options;

      &I-D.ietf-tsvwg-sctp-dtls-encaps;

      &I-D.ietf-quic-transport;
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC1191;

      &RFC4821;

      &RFC2923;

      &RFC4340;

      &RFC4890;
    </references>

    <section anchor="StateChanges" title="Event-driven state changes">
      <t>This appendix contains an informative description of key events:</t>

      <t><list style="hanging">
          <t hangText="Path Setup:">When a new path is initiated, the state is
          set to PROBE_START. As soon as the path is confirmed, the state
          changes to PROBE_BASE and the probing mechanism for this path is
          started. the first probe packet is sent with the size of the
          BASE_PMTU.</t>

          <t hangText="Arrival of an Acknowledgment:">Depending on the probing
          state, the reaction differs according to <xref
          target="fig-acks"></xref>, which is just a simplification of <xref
          target="fig-states"></xref> focusing on this event. <figure
              anchor="fig-acks"
              title="State changes at the arrival of an acknowledgment">
              <artwork align="center"><![CDATA[
+--------------+                                    +----------------+
|  PROBE_START | --3------------------------------->| PROBE_DISABLED |
+--------------+ --4-----------\                    +----------------+
                                \
+--------------+                 \
| PROBE_ERROR  | ---------------  \
+--------------+                \  \
                                 \  \
+--------------+                  \  \              +--------------+
|  PROBE_BASE  | --1----------     \  ------------> |  PROBE_BASE  |
+--------------+ --2-----     \     \               +--------------+
                         \     \     \
+--------------+          \     \     ------------> +--------------+
| PROBE_SEARCH | --2---    \     -----------------> | PROBE_SEARCH |
+--------------+ --1---\----\---------------------> +--------------+
                        \    \
+--------------+         \    \                     +--------------+
|  PROBE_DONE  |          \    -------------------> |  PROBE_DONE  |
+--------------+           -----------------------> +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum PMTU size has not yet been
              reached. Condition 2: The maximum PMTU size has been reached.
              Conition 3: Probe Timer expires and PROBE_COUNT = MAX_PROBEs.
              Condition 4: PROBE_ACK received.</postamble>
            </figure></t>

          <t hangText="Probing timeout:">The PROBE_COUNT is initialised to
          zero each time the value of PROBED_SIZE is changed. The PROBE_TIMER
          is started each time a probe packet is sent. It is stopped when an
          acknowledgment arrives that confirms delivery of a probe packet. If
          the probe packet is not acknowledged before the PROBE_TIMER expires,
          the PROBE_ERROR_COUNTER is incremented. When the PROBE_COUNT equals
          the value MAX_PROBES, the state is changed, otherwise a new probe
          packet of the same size (PROBED_SIZE) is resent. The state
          transitions are illustrated in <xref
          target="fig-probeTimer"></xref>. This shows a simplification of
          <xref target="fig-states"></xref> with a focus only on this event.
          <figure anchor="fig-probeTimer"
              title="State changes at the expiration of the probe timer">
              <artwork align="center"><![CDATA[
+--------------+                                    +----------------+
|  PROBE_START |----------------------------------->| PROBE_DISABLED |
+--------------+                                    +----------------+

+--------------+                                    +--------------+
| PROBE_ERROR  |                 -----------------> | PROBE_ERROR  |
+--------------+                /                   +--------------+
                               /
+--------------+ --2----------/                     +--------------+
|  PROBE_BASE  | --1------------------------------> |  PROBE_BASE  |
+--------------+                                    +--------------+

+--------------+                                    +--------------+
| PROBE_SEARCH | --1------------------------------> | PROBE_SEARCH |
+--------------+ --2---------                       +--------------+
                             \
+--------------+              \                     +--------------+
|  PROBE_DONE  |               -------------------> |  PROBE_DONE  |
+--------------+                                    +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum number of probe packets has
              not been reached. Condition 2: The maximum number of probe
              packets has been reached.</postamble>
            </figure></t>

          <t hangText="PMTU raise timer timeout:">The path through the network
          can change over time. It impossible to discover whether a path
          change has increased the actual PMTU by exchanging packets less than
          or equal to the PLPMTU. This requires PLPMTUD to periodically send a
          probe packet to detect whether a larger PMTU is possible. This probe
          packet is generated by the PMTU_RAISE_TIMER. When the timer expires,
          probing is restarted with the BASE_PMTU and the state is changed to
          PROBE_BASE.</t>

          <t hangText="Arrival of an ICMP message:">The active probing of the
          path can be supported by the arrival of PTB messages sent by routers
          or middleboxes with a link MTU that is smaller than the probe packet
          size. If the PTB message includes the router link MTU, three cases
          can be distinguished:</t>

          <t><list style="numbers">
              <t>The indicated link MTU in the PTB message is between the
              already probed and PLMTU and the probe that triggered the PTB
              message.</t>

              <t>The indicated link MTU in the PTB message is smaller than the
              PLPMTU.</t>

              <t>The indicated link MTU in the PTB message is equal to the
              BASE_PMTU.</t>
            </list></t>

          <t>In first case, the PROBE_BASE state transitions to the
          PROBE_ERROR state. In the PROBE_SEARCH state, a new probe packet is
          sent with the sized reported by the PTB message. Its result is
          handled according to the former events.</t>

          <t>The second case could be a result of a network re-configuration.
          If the reported link MTU in the PTB message is greater than the
          BASE_MTU, the probing starts again with a value of PROBE_BASE.
          Otherwise, the method enters the state PROBE_ERROR.</t>

          <t>In the third case, the maximum possible PMTU has been reached.
          This ought to be probed again, because there could be a link further
          along the path with a still smaller MTU.</t>

          <t>Note: Not all routers include the link MTU size when they send a
          PTB message. If the PTB message does not indicate the link MTU, the
          probe is handled in the same way as condition 2 of <xref
          target="fig-probeTimer"></xref>.</t>
        </list></t>
    </section>

    <section title="Revision Notes">
      <t>Note to RFC-Editor: please remove this entire section prior to
      publication.</t>

      <t>Individual draft -00: <list style="symbols">
          <t hangText="Individual draft -00">Comments and corrections are
          welcome directly to the authors or via the IETF TSVWG working group
          mailing list.</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Individual draft -01:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">Contains the first representation
          of the algorithm, showing the states and timers</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Individual draft -02:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">Contains updated representation
          of the algorithm, and textual corrections.</t>

          <t hangText="Individual draft -00">The text describing when to set
          the effective PMTU has not yet been verified by the authors</t>

          <t hangText="Individual draft -00">To determine security to
          off-path-attacks: We need to decide whether a received PTB message
          SHOULD/MUST be verified? The text on how to handle a PTB message
          indicating a link MTU larger than the probe has yet not been
          verified by the authors</t>

          <t hangText="Individual draft -00">No text currently describes how
          to handle inconsistent results from arbitrary re-routing along
          different parallel paths</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Working Group draft -00:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">This draft follows a successful
          adoption call for TSVWG</t>

          <t hangText="Individual draft -00">There is still work to complete,
          please comment on this draft.</t>
        </list>Working Group draft -01:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">This draft includes improved
          introduction.</t>

          <t hangText="Individual draft -00">The draft is updated to require
          ICMP validation prior to accepting PTB messages - this to be
          confirmed by WG</t>

          <t hangText="Individual draft -00">Section added to discuss
          Selection of Probe Size - methods to be evlauated and
          recommendations to be considered</t>

          <t hangText="Individual draft -00">Section added to align with work
          proposed in the QUIC WG.</t>
        </list>Working Group draft -02:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">The draft was updated based on
          feedback from the WG, and a detailed review by Magnus
          Westerlund.</t>

          <t hangText="Individual draft -00">The document updates RFC
          4821.</t>

          <t hangText="Individual draft -00">Requirements list updated.</t>

          <t hangText="Individual draft -00">Added more explicit discussion of
          a simpler black-hole detection mode.</t>

          <t hangText="Individual draft -00">This draft includes
          reorganisation of the section on IETF protocols.</t>

          <t hangText="Individual draft -00">Added more discussion of
          implementation within an application.</t>

          <t hangText="Individual draft -00">Added text on flapping paths.</t>

          <t hangText="Individual draft -00">Replaced 'effective MTU' with new
          term PLPMTU.</t>
        </list></t>
    </section>
  </back>
</rfc>
