<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
    which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
    There has to be one entity for each item to be referenced.
    An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC678 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0678.xml">
<!ENTITY RFC768 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC792 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0792.xml">
<!ENTITY RFC1122 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml">
<!ENTITY RFC1123 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml">
<!ENTITY RFC1812 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1812.xml">
<!ENTITY RFC1191 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1191.xml">
<!ENTITY RFC1981 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1981.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2460 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC2475 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2475.xml">
<!ENTITY RFC2553 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2553.xml">
<!ENTITY RFC2923 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2923.xml">
<!ENTITY RFC3168 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml">
<!ENTITY RFC3260 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3260.xml">
<!ENTITY RFC3395 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3395.xml">
<!ENTITY RFC3396 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3396.xml">
<!ENTITY RFC3493 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml">
<!ENTITY RFC3552 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC3678 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3678.xml">
<!ENTITY RFC3828 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3828.xml">
<!ENTITY RFC4340 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4340.xml">
<!ENTITY RFC4820 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4820.xml">
<!ENTITY RFC4821 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4821.xml">
<!ENTITY RFC4828 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4828.xml">
<!ENTITY RFC4890 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4890.xml">
<!ENTITY RFC4960 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5082 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5082.xml">
<!ENTITY RFC5097 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5097.xml">
<!ENTITY RFC5226 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY RFC6679 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6679.xml">
<!ENTITY RFC6935 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6935.xml">
<!ENTITY RFC6936 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6936.xml">
<!ENTITY RFC6951 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6951.xml">
<!ENTITY RFC6968 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6968.xml">
<!ENTITY RFC6633 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6633.xml">
<!ENTITY RFC8085 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8085.xml">
<!ENTITY RFC8201 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml">
<!ENTITY I-D.ietf-tsvwg-udp-options SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-udp-options-01.xml">
<!ENTITY I-D.ietf-tsvwg-sctp-dtls-encaps SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-tsvwg-sctp-dtls-encaps-09.xml">
<!ENTITY I-D.ietf-quic-transport SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-quic-transport-04.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
    please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
    (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
    (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-fairhurst-tsvwg-datagram-plpmtud-01.txt"
     ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: trust200902, noModificationTrust200902, noDerivativesTrust200902,
                 or pre5378Trust200902
    you can add the attributes updates="NNNN" and obsoletes="NNNN"
    they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
     full title is longer than 39 characters -->

    <title abbrev="Datagram PLPMTUD ">Packetization Layer Path MTU Discovery
    for Datagram Transports</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Godred Fairhurst" initials="G" surname="Fairhurst">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3UE</code>

          <country>UK</country>
        </postal>

        <email>gorry@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Tom Jones" initials="T" surname="Jones">
      <organization>University of Aberdeen</organization>

      <address>
        <postal>
          <street>School of Engineering</street>

          <street>Fraser Noble Building</street>

          <city>Aberdeen</city>

          <region></region>

          <code>AB24 3UE</code>

          <country>UK</country>
        </postal>

        <email>tom@erg.abdn.ac.uk</email>
      </address>
    </author>

    <author fullname="Michael Tuexen" initials="M" surname="Tuexen">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Steinfurt</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>tuexen@fh-muenster.de</email>
      </address>
    </author>

    <author fullname="Irene Ruengeler" initials="I" surname="Ruengeler">
      <organization>Muenster University of Applied Sciences</organization>

      <address>
        <postal>
          <street>Stegerwaldstrasse 39</street>

          <code>48565</code>

          <city>Steinfurt</city>

          <region></region>

          <country>DE</country>
        </postal>

        <email>i.ruengeler@fh-muenster.de</email>
      </address>
    </author>

    <date day="30" month="October" year="2017" />

    <!-- Meta-data Declarations -->

    <area>Transport</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
     IETF is fine for individual submissions. If this element is not
     present, the default is "Network Working Group", which is used by the
     RFC Editor as a nod to the history of the IETF. -->

    <keyword>UDP SCTP Transport PMTUD PLPMTUD</keyword>

    <!-- Keywords will be incorporated into HTML output
     files in a meta tag but they have no effect on text or nroff output. If
     you submit your draft to the RFC Editor, the keywords will be used for
     the search engine. -->

    <abstract>
      <t>This document describes a robust method for Path MTU Discovery
      (PMTUD) for datagram packetization layers. This allows these layers to
      probe an Internet path with progressively larger packets to determine a
      maximum packet size. This method is described as an extension to RFC
      1191 and RFC 8201, which specify ICMP-based Path MTU Discovery for IP
      versions 4 and 6. The document provides functionally for datagram
      transports that is equivalent to the packetization layer PMTUD
      specification for TCP, specified in RFC4821.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The IETF has specified datagram transport using UDP, SCTP, SCTP/UDP,
      EXP, and DCCP/UDP, as well as protocols layered on top of these
      transports.</t>

      <t>Classical Path Maximum Transmission Unit Discovery (PMTUD) can be
      used with any transport that is able to process IMP Packet Too Big (PTB)
      messages (e.g., <xref target="RFC1191"></xref> and <xref
      target="RFC8201"></xref>). It adjusts the effective Path MTU (PMTU),
      based on reception of IMP Path too Big (PTB) messages to decrease the
      PMTU when a packet is sent with a size larger than the value supported
      along a path, and a method that from time-to-time increases the packet
      size in attempt to discover an increase in the supported PMTU.</t>

      <t>However, Classical PMTUD is subject to protocol failures. One failure
      arises when traffic using a packet size larger than the actual supported
      PMTU is blackholed (silently discarded). This may continue to happen
      when IMP PTB messages are not delivered back to the sender for some
      reason <xref target="RFC2923"></xref>). For example, IMP messages are
      increasingly filtered by middleboxes (including firewalls) <xref
      target="RFC4890"></xref>, and may not be correctly processed by tunnel
      endpoints.</t>

      <t>Another failure could result if a system not on the path sends a PTB
      that attempts to force the sender to change the effective PMTU <xref
      target="RFC8201"></xref>. A sender could protect itself by using the
      quoted packet within the PTB message payload to verify that the received
      PTB message was generated in response to a packet that had actually been
      sent. However, there are situations where a sender is unable to provide
      this verification (e.g., when the PTB message does not include
      sufficient information, often the case for IPv4; or where the
      information corresponds to an encrypted packet). Most routers implement
      RFC792 <xref target="RFC0792"></xref>, which requires them to return only
      the first 64 bits of the IP payload of the packet, whereas RFC1812 <xref
      target="RFC1812"></xref> requires routers to return the full packet if
      possible.</t>

      <t>Even when the PTB message includes sufficient bytes of the quoted
      packet, the network layer may lack sufficient context to perform this
      verification, because this depends on information about the active
      transport flows (e.g., the socket/address pairs being used, and other
      protocol header information).</t>

      <t>The term Packetization Layer has been introduced to describe the
      layer that is responsible for placing data blocks into the payload of
      packets and selecting an appropriate maximum packet size. This function
      is often performed by a transport protocol, but can also be performed by
      other encapsulation methods working below the application. PTB
      verification is more straight forward at a the Packetization Layer (PL)
      or a higher layer.</t>

      <t>In contrast to PMTUD, Packetization Layer Path MTU Discovery
      (PLPMTUD) <xref target="RFC4821"></xref> does not rely upon reception
      and verification of PTB messages. It is therefore more robust than
      Classical PMTUD. This has become the recommended approach for
      implementing PMTU discovery with TCP. It uses a general strategy where
      the PL searches for an appropriate PMTU by sending probe packets along
      the network path with a progressively larger packet size. If a probe
      packet is successfully delivered (as determined by the PL), then the
      effective Path MTU is raised to the probe size.</t>

      <t>PLPMTUD introduces flexibility in the implementation of PMTU
      discovery. At one extreme, it can be configured to only perform PTB
      black hole recovery to increase the robustness of Classical PMTUD, or at
      the other extreme, all PTB processing can be disabled and PLPMTUD can
      completely replace Classical PMTUD. PLPMTUD can also include additional
      consistency checks without increasing the risk of blackholing.</t>

      <t>The UDP-Guidelines <xref target="RFC8085"></xref> state "an
      application SHOULD either use the path MTU information provided by the
      IP layer or implement Path MTU Discovery (PMTUD)", but does not provide
      a mechanism for discovering the largest size of unfragmented datagram
      than can be used on a path. PLPMTUD has not currently been specified for
      UDP, while Section 10.2 of <xref target="RFC4821"></xref> recommends a
      PLPMTUD probing method for SCTP that utilises heartbeat messages as
      packet probes, but does not provide a complete specification. This
      document provides the details to complete that specification. Similarly,
      the method defined in this specification could be used with the Datagram
      Congestion Control Protocol (EXP) <xref target="RFC4340"></xref>
      requires implementations to support Classical PMTUD and states that a
      EXP sender "MUST maintain the maximum packet size (MPS) allowed for each
      active EXP session". It also defines the current congestion control
      maximum packet size (CCMPS) supported by a path. This recommends use of
      PMTUD, and suggests use of control packets (DCCP-Sync) as path probe
      packets, because they do not risk application data loss. The document
      also contains information that enables the implementation of PLPMTUD
      with other datagram transports.</t>

      <t><xref target="Spec"></xref> of this document presents a set of
      algorithms for datagram protocols to discover a maximum size for the
      effective PMTU across a path. The methods described rely on features of
      the PL <xref target="Requirements"></xref> and apply to transport
      protocols over IPv4 and IPv6. It does not require cooperation from the
      lower layers (except that they are consistent about which packet sizes
      are acceptable). A method can utilise PTB messages when these are
      available.</t>
    </section>

    <section title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref>.</t>

      <t>Other terminology is directly copied from <xref
      target="RFC4821"></xref>, and the definitions in <xref
      target="RFC1122"></xref>.</t>

      <t><list style="hanging">
          <t hangText="Black-Holed:">When the sender is unaware that packets
          are not delivered to the destination endpoint (e.g., when the sender
          is unaware of a change in the path to one with a smaller PMTU).</t>

          <t hangText="Classical Path MTU Discovery:">Classical PMTUD is a
          process described in <xref target="RFC1191"></xref> and <xref
          target="RFC8201"></xref>, in which nodes rely on PTB messages to
          learn the largest size of unfragmented datagram than can be used
          across a path.</t>

          <t hangText="Datagram:">A datagram is a transport-layer protocol
          data unit, transmitted in the payload of an IP packet.</t>

          <t hangText="Effective PMTU:">The current estimated value for PMTU
          used by a Packetization Layer.</t>

          <t hangText="EMTU_S:">The Effective MTU for sending (EMTU_S) is
          defined in <xref target="RFC1122"></xref> as "the maximum IP
          datagram size that may be sent, for a particular combination of IP
          source and destination addresses...".</t>

          <t hangText="EMTU_R:">The Effective MTU for receiving (EMTU_R) is
          designated in <xref target="RFC1122"></xref> as the largest datagram
          size that can be reassembled by EMTU_R ("Effective MTU to
          receive").</t>

          <t hangText="Link:">A communication facility or medium over which
          nodes can communicate at the link layer, i.e., a layer below the IP
          layer. Examples are Ethernet LANs and Internet (or higher) layer and
          tunnels.</t>

          <t hangText="Link MTU:">The Maximum Transmission Unit (MTU) is the
          size in bytes of the largest IP packet, including the IP header and
          payload, that can be transmitted over a link. Note that this could
          more properly be called the IP MTU, to be consistent with how other
          standards organizations use the acronym MTU. This includes the IP
          header, but excludes link layer headers and other framing that is
          not part of IP or the IP payload. Other standards organizations
          generally define link MTU to include the link layer headers.</t>

          <t hangText="MPS:">The Maximum Packet Size (MPS), the largest size
          of application data block that may be sent unfragmented across a
          path. In PLPMTUD this quantity is derived from Effective PMTU by
          taking into consideration the size of the application and lower
          protocol layer headers, and may be limited by the application
          protocol.</t>

          <t hangText="Packet:">An IP header plus the IP payload.</t>

          <t hangText="Packetization Layer (PL):">The layer of the network
          stack that places data into packets and performs transport protocol
          functions.</t>

          <t hangText="Path:">The set of link and routers traversed by a
          packet between a source node and a destination node.</t>

          <t hangText="Path MTU (PMTU):">The minimum of the link MTU of all
          the links forming a path between a source node and a destination
          node.</t>

          <t hangText="PLPMTUD:">Packetization Layer Path MTU Discovery, the
          method described in this document for datagram PLs, which is an
          extension to Classical PMTU Discovery.</t>
        </list></t>
    </section>

    <section anchor="Requirements"
             title="Features required to provide PLPMTUD at the Transport Layer">
      <t>TCP PLPMTUD has been defined using standard TCP protocol mechanisms.
      All of the requirements in <xref target="RFC4821"></xref> also apply to
      use of the technique with a datagram PL. Unlike TCP, some datagram PLs
      require additional mechanisms to implement PLPMTUD.</t>

      <t>There are ten requirements for performing the datagram PLPMTUD method
      described in this specification: <list style="numbers">
          <t>PMTU parameters: A PLPMTUD sender is REQUIRED to provide
          information about the maximum size of packet that can be transmitted
          by the sender on the local link (the Link MTU and MAY utilize
          similar information about the receiver when this is supplied (note
          this may be less than EMTU_R). Some applications also have a maximum
          transport protocol data unit (PDU) size, in which case there may be
          no benefit from probing for a size larger than this (unless a
          transport allows multiplexing multiple applications PDUs into the
          same datagram).</t>

          <t>Effective PMTU: A datagram application MUST be able to choose the
          size of datagrams sent to the network, up to the effective PMTU, or
          a smaller value (such as the MPS) derived from this. This value is
          managed by the PMTUD method. The effective PMTU (specified in
          Section 1 of <xref target="RFC1191"></xref>) is equivalent to the
          EMTU_S (specified in <xref target="RFC1122"></xref>).</t>

          <t>Probe packets: On request, a PLPMTUD sender is REQUIRED to be
          able to transmit a packet larger than the current effective PMTU
          (but always with a total size less than the link MTU), which the
          method can use as a probe packet. In IPv4, a probe packet is always
          sent with the Don't Fragment (DF) bit set and without network layer
          endpoint fragmentation.</t>

          <t>Processing PTB messages: A PLPMTUD sender MAY optionally utilize
          PTB messages received from the network layer to help identify when a
          path does not support the current size of packet probe. Any received
          PTB message SHOULD/MUST be verified before it is used to update the
          PMTU discovery information <xref target="RFC8201"></xref>. This
          verification confirms that the PTB message was sent in response to a
          packet originating by the sender, and needs to be performed before
          the PMTU discovery method reacts to the PTB message. When the router
          link MTU is indicated in the PTB message this MAY be used by
          datagram PLPMTUD to reduce the size of a probe, but MUST NOT be used
          increase the effective PMTU.</t>

          <t>Reception feedback: The destination PL endpoint is REQUIRED to
          provide a feedback method that indicates when a probe packet has
          been received by the destination endpoint. The local PL endpoint is
          REQUIRED to pass this feedback to the sender PLPMTUD method.</t>

          <t>Probing and congestion control: The isolated loss of a probe
          packet SHOULD NOT be treated as an indication of congestion and its
          loss not directly trigger a congestion control reaction.</t>

          <t>Probe loss recovery: If the data block carried by a probe message
          needs to be sent reliably, the PL (or layers above) MUST arrange
          retransmission/repair of any resulting loss. This method MUST be
          robust in the case where packet probes are lost due to other reasons
          (including link transmission error, congestion). The PLPMTUD method
          treats isolated loss of a probe packet (with or without an PTB
          message) as a potential indication of a PMTU limit on the path. The
          PL is permitted to retransmit any data included in a lost probe
          packet without adjusting its congestion window.</t>

          <t>Cached effective PMTU: The sender MUST cache the effective PMTU
          value between probes and needs also to consider the disruption that
          could be incurred by an unsuccessful probe - both upon the flow that
          incurs a probe loss, and other flows that experience the effect of
          additional probe traffic.</t>

          <t>Shared effective PMTU state: The specification of PLPMTUD <xref
          target="RFC4821"></xref> states: "If PLPMTUD updates the MTU for a
          particular path, all Packetization Layer sessions that share the
          path representation (as described in Section 5.2 of <xref
          target="RFC4821"></xref>) SHOULD be notified to make use of the new
          MTU and make the required congestion control adjustments". Such
          methods need to robust to the wide variety of underlying network
          forwarding behaviours. Considerations about caching have been noted
          <xref target="RFC8201"></xref>.</t>
        </list>In addition the following design principles are stated:</t>

      <t><list style="symbols">
          <t>Suitable MPS: The PLPMTUD method SHOULD avoid forcing an
          application to use an arbitrary small MPS (effective PMTU) for
          transmission while the method is searching for the currently
          supported PMTU. Datagram PLs do not necessarily support
          fragmentation of PDUs larger than the PMTU. A reduced MPS can
          adversely impact the performance of a datagram application.</t>

          <t>Path validation: The PLPMTUD method MUST be robust to path
          changes that could have occurred since the path characteristics were
          last confirmed.</t>

          <t>Datagram reordering: A method MUST be robust to the possibility
          that a flow encounters reordering, or has the traffic (including
          probe packets) is divided over more than one network path.</t>

          <t>When to probe: The PLPMTUD method SHOULD determine whether the
          path capacity has increased since it last measured the path. This
          determines when the path should again be probed.</t>
        </list></t>

      <section title="PMTU Probe Packets">
        <t>PMTU discovery relies upon the sender being able to generate probe
        messages with a specific size. TCP is able to generate probe packets
        by choosing to appropriately segment data being sent <xref
        target="RFC4821"></xref>.</t>

        <t>In contrast, datagram PLs either have to request an application to
        send a data block with a specified size, or to utilise padding
        functions to extend the datagram beyond the size of the application
        data block. Protocols that permit exchange of control messages
        (without an application data block) could alternatively prefer to
        generate a probe packet by extending a control message with padding
        data.</t>

        <t>When the method fails to validate the PMTU for the path, the
        required size of probe packet can need to be less than the size of the
        data block generated by an application. In this case, the PL could
        provide a way to fragment a datagram at the PL, or could instead
        utilise a control packet with padding.</t>

        <t>A receiver needs to be able to distinguish an in-band data block
        from any added padding. This is needed to ensure that any added
        padding is not passed on to an application at the receiver.</t>

        <t>This results in three ways that a sender can create a probe
        packet:<list style="hanging">
            <t hangText="Probing using appication data:">A probe packet that
            contains a data block supplied by an application that matches the
            size required for the probe. This requires a method to request the
            application to issue a data block of the desired probe size. If
            the application/transport needs protection from the loss of this
            probe packet, the application/transport needs then to perform
            transport-layer retransmission/repair of the data block (e.g., by
            retransmission after loss is detected or by duplicating the data
            block in a datagram without the padding).</t>

            <t hangText="Probing using appication data:">A probe packet that
            contains a data block supplied by an application that is combined
            with padding to inflate the length of the datagram to the size
            required for the probe. If the application/transport needs
            protection from the loss of this probe packet, the
            application/transport may perform transport-layer
            retransmission/repair of the data block (e.g., by retransmission
            after loss is detected or by duplicating the data block in a
            datagram without the padding data).</t>

            <t hangText="Probing using appication data:">A probe packet that
            contains only control information together with padding needed to
            inflate the packet to the size required for the probe. Since these
            probe packets do not carry an application-supplied data block,they
            do not typically require retransmission, although they do still
            consume network capacity.</t>
          </list></t>
      </section>

      <section title="Validation of the current effective PMTU">
        <t>The PL needs a method to determine when packet probes have been
        successfully received end-to-end across a network path.</t>

        <t>Transport protocols can include end-to-end methods that detect and
        report reception of specific datagrams that they send (e.g., EXP and
        SCTP provide keep-alive/heartbeat features). This can also be used by
        PLPMTUD to acknowledge reception of a probe packet.</t>

        <t>A PL that does not acknowledge data reception (e.g., UDP and
        UDP-Lite) is unable to detect when the packets it sends are discarded
        because their size is greater than the actual PMTUD. These PLs need to
        either rely on an application protocol to detect this, or make use of
        an additional transport method such as UDP-Options <xref
        target="I-D.ietf-tsvwg-udp-options"></xref>. In addition, they might
        need to send reachability probes (e.g., periodically solicit a
        response from the destination) to determine whether the current
        effective PMTU is still supported by the network path.</t>
      </section>

      <section title="Reduction of the effective PMTU">
        <t>When the current effective PMTU is no longer supported by the
        network path, the transport needs to detect this and reduce the
        effective PMTU.</t>

        <t><list style="symbols">
            <t>A PL that sends a datagram larger than the actual PMTU that
            includes no application data block, or one that does not attempt
            to provide any retransmission, can send a new probe packet with an
            updated probe size.</t>

            <t>A PL that wishes to resend the application data block, may need
            to re-fragment the data block to a smaller datagram size. This
            could utilise network-layer or PL fragmentation when these are
            available.</t>
          </list></t>

        <t>A method can utilise PTB messages to detect when the actual PMTU
        supported by a network path is less than the current size of datagrams
        (or probe messages) that are being sent.</t>
      </section>
    </section>

    <section anchor="Spec" title="Datagram PLPMTUD">
      <t>This section specifies Datagram PLPMTUD.</t>

      <t>The central idea of PLPMTU discovery is probing by a sender. Probe
      packets of increasing size are sent to find out the maximum size of a
      user message that is completely transferred across the network path from
      the sender to the destination. If a PTB message is received from a
      router or middlebox, this information ought to be verified and SHOULD
      used.</t>

      <t>A method that can also utilise PTB messages can improve performance
      compared to one that relies solely on probing.</t>

      <section title="Probing">
        <t>The PLPMTUD method utilises a timer to trigger the generation of
        probe packets. The probe_timer is started each time a probe packet is
        sent to the destination and is cancelled when receipt of the probe
        packet is acknowledged. Each time the probe_timer expires, the
        PROBE_COUNT is incremented, and the probe packet of the same size is
        retransmitted. The counter is initialised to zero when a probe packet
        is first sent with a particular size. The maximum number of
        retransmissions per probing size is configured (MAX_PROBES). If the
        value of the PROBE_COUNT exceeds MAX_PROBES, probing will be stopped
        and the last successfully probed PMTU is set as the effective
        PMTU.</t>

        <t>Once probing is completed, the sender continues to use the
        effective PMTU until either a PTB message is received or the
        PMTU_RAISE_TIMER expires. If the PL is unable to verify reachability
        to the destination endpoint after probing has completed, the method
        uses a REACHABILITY_TIMER to periodically repeat a probe packet for
        the current effective PMTU size, while the PMTU_RAISE_TIMER is
        running. If the resulting probe packet is not acknowledged (i.e. the
        PROBE_TIMER expires), the method re-starts probing for the PMTU.</t>
      </section>

      <section title="Timers">
        <t>This method utilises three timers:<list style="hanging">
            <t hangText="PROBE_TIMER:">Configured to expire after a period
            longer than the maximum time to receive an acknowledgment to a
            probe packet.</t>

            <t hangText="PMTU_RAISE_TIMER:">Configured to the period a sender
            ought to continue use the current effective PMTU, after which it
            re-commences probing for a higher PMTU. This timer has a period of
            600 secs, as recommended by <xref target="RFC4821"></xref>.</t>

            <t hangText="REACHABILITY_TIMER:">Configured to the period a
            sender ought to wait before confirming the current effective PMTU
            is still supported. This is less than the PMTU_RAISE_TIMER.</t>
          </list></t>

        <t>An implementation could implement the various timers using a single
        timer process.</t>
      </section>

      <section title="Constants">
        <t>The following constants are defined:</t>

        <t><list style="hanging">
            <t hangText="MAX_PROBES:">The maximum value of the
            PROBE_ERROR_COUNTER.</t>

            <t hangText="MIN_PMTU:">The smallest allowed probe packet size.
            This value is 1280 bytes, as specified in <xref
            target="RFC2460"></xref>.</t>

            <t hangText="BASE_PMTU:">The BASE_PMTU is a considered a size that
            ought to work in most cases. The size is equal to or larger than
            the minimum permitted and smaller than the maximum allowed. In the
            case of IPv6, this value is 1280 bytes as specified in <xref
            target="RFC2460"></xref>. When using IPv4, a size of 1200 is
            RECOMMENDED.</t>

            <t hangText="MAX_PMTU:">The MAX_PMTU is the largest size of PMTU
            that is probed. This has be less than or equal to the minimum of
            the local MTU of the outgoing interface and the destination
            effective MTU for receiving.</t>
          </list></t>
      </section>

      <section title="Variables">
        <t>This method utilises a set of variables: <list style="hanging">
            <t hangText="effective PMTU:">The effective PMTU is the maximum
            size of datagram that the method has currently determined can be
            supported along the entire path.</t>

            <t hangText="PROBED_SIZE:">The PROBED_SIZE is the size of the
            current probe packet. This is a tentative value for the effective
            PMTU, which is awaiting confirmation by an acknowledgment.</t>

            <t hangText="PROBE_COUNT:">This is a count of the number of
            unsuccessful probe packets that have been sent with size
            PROBED_SIZE. The value is initialised to zero when a particular
            size of PROBED_SIZE is first attempted.</t>

            <t hangText="PTB_SIZE:">The PTB_Size is value returned by a
            verified PTB message indicating the local MTU size of a router
            along the path.</t>
          </list></t>
      </section>

      <section anchor="States" title="State Machine">
        <t>A state machine for Datagram PLPMTUD is depicted in <xref
        target="fig-states"></xref>. If multihoming is supported, a state
        machine is needed for each active path.</t>

        <figure anchor="fig-states" title="State machine for Datagram PLPMTUD">
          <artwork align="center"><![CDATA[
                            +------------+
                            | PROBE_NONE |
                            +------------+
                                   |  Connectivity confirmed
                                   v
                   ---------- +------------+ -- PROBE_TIMER expiry
MAX_PMTU acked    |           | PROBE_BASE |  | (PROBE_COUNT < MAX_PROBES)
PTB (>= BASE_PMTU)|    -----> +------------+ <-
  ----------------     |          /\   |  |
  |                    |           |   |  | PTB
  |    PMTU_RAISE_TIMER|           |   |  | (PTB_SIZE < BASE_PMTU)
  |    or reachability |           |   |  |        or
  |     (PROBE_COUNT   |           |   |  |    PROBE_TIMER expiry
  |      = MAX_PROBES) |           |   |  | (PROBE_COUNT = MAX_PROBES)
  |        -------------           |   |   \      
  |        |                   PTB |   |    \  
  |        |        (< PROBED_SIZE)|   |     \ 
  |        |                       |   |      ---------------
  |        |                       |   |                     |
  |        |                       |   | Probe               |
  |        |                       |   | acked               |
  v        |                       |   v                     v
+------------+                +--------------+  Probe +-------------+
| PROBE_DONE |<-------------- | PROBE_SEARCH |<-------| PROBE_ERROR |
+------------+ MAX_PMTU acked +--------------+  acked +-------------+
 /\    |             or            /\      |
  |    |      PROBE_TIMER expiry    |      |
  |    |(PROBE_COUNT = MAX_PROBES)  |      | 
  |    |                            |      |                 
  -----                              ------
Reachability probe acked      PROBE_TIMER expiry                     
 or PROBE_TIMER expiry      (PROBE_COUNT < MAX_PROBES)
(PROBE_COUNT < MAX_PROBES)

]]></artwork>
        </figure>

        <t>The following states are defined to reflect the probing
        process:</t>

        <t><list style="hanging">
            <t hangText="PROBE_NONE:">The PROBE_NONE state is the initial
            state before probing has started. PLPMTUD is not performed in this
            state. The state transitions to PROBE_BASE, when a path has been
            confirmed, i.e. when a packet has arrived on this path. The
            effective PMTU is set to the BASE_PMTU size. Probing ought to
            start immediately after connection setup to prevent the loss of
            user data.</t>

            <t hangText="PROBE_BASE:">The PROBE_BASE state is the starting
            point for probing with datagram PLPMTUD, and is used to confirm
            whether the BASE_PMTU size is supported by the network path. On
            entry, the PROBED_SIZE is set to the BASE_PMTU size and the
            PROBE_COUNT is set to zero. A probe packet is sent, and the
            PROBE_TIMER is started. The state is left when the PROBE_COUNT
            reaches MAX_PROBES; a PTB message is received, or a probe packet
            is acknowledged.</t>

            <t hangText="PROBE_SEARCH:">The PROBE_SEARCH state is the main
            probing state. This state is entered either when probing for the
            BASE_PMTU was successful or when there is a successful
            reachability test in the PROBE_ERROR state. On entry, the
            effective PMTU is set to the last acknowledged PROBED_SIZE.</t>

            <t hangText="">On the first probe packet for each probed size, the
            PROBE_COUNT is set to zero. Each time a probe packet is
            acknowledged, the effective PMTU is set to the PROBED_SIZE, and
            then the PROBED_SIZE is increased. When a probe packet is not
            acknowledged within the period of the PROBE_TIMER, the PROBE_COUNT
            is incremented and the probe packet is retransmitted. The state is
            exited when the PROBE_COUNT reaches MAX_PROBES; a PTB message is
            verified; or a probe of size PMTU_MAX is acknowledged.</t>

            <t hangText="PROBE_ERROR:">The PROBE_ERROR state represents the
            case where the network path is not known to support an effective
            PMTU of at least the BASE_PMTU size. It is entered when either a
            probe of size BASE_PMTU has not been acknowledged or a verified
            PTB message indicates a smaller link MTU than the BASE_PMTU. On
            entry, the PROBE_COUNT is set to zero and the PROBED_SIZE is set
            to the MIN_PMTU size, and the effective PMTU is reset to MIN_PMTU
            size. In this state, a probe packet is sent, and the PROBE_TIMER
            is started. The state transitions to the PROBE_SEARCH state when a
            probe packet is acknowledged.</t>

            <t hangText="PROBE_DONE:">The PROBE_DONE state indicates a
            successful end to a probing phase. Datagram PLPMTUD remains in
            this state until either the PMTU_RAISE_TIMER expires or a PTB
            message is verified.</t>

            <t hangText="">When PLPMTUD uses an unacknowledged PL and is in
            the PROBE_DONE state, a REACHABILITY_TIMER periodically resets the
            PROBE_COUNT and schedules a probe packet with the size of the
            effective PMTU. If the probe packet fails to be acknowledged after
            MAX_PROBES attempts, the method enters the PROBE_BASE state. An
            acknowledged PL (e.g., SCTP) )SHOULD NOT continue to probe in this
            state.</t>

            <t></t>
          </list><xref target="StateChanges"></xref> contains an informative
        description of key events:</t>
      </section>
    </section>

    <section anchor="protocol_specific_methods"
             title="Specification of Protocol-Specific Methods">
      <t>This section specifies protocol-specific details for datagram PLPMTUD
      for IETF-specified transport protocols.</t>

      <section title="UDP and UDP-Lite">
        <t>The current specifications of UDP and UDP-LIte <xref
        target="RFC3828"></xref> do not define a method in the RFC-series that
        supports PLPMTUD. In particular, these transport do not provide the
        transport layer features needed to implement datagram PLPMTUD, and any
        support for Datagram PLPMTUD would therefore need to rely on
        higher-layer protocol features.</t>

        <section title="UDP Options">
          <t>UDP-Options <xref target="I-D.ietf-tsvwg-udp-options"></xref>
          supply the additional functionality required to implement datagram
          PLPMTUD. This enables padding to be added to UDP datagrams and can
          be used to provide feedback acknowledgement of received probe
          packets.</t>
        </section>

        <section anchor="UDPOPT-PLPMTUD"
                 title="UDP Options required for PLPMTUD">
          <t>This subsection proposes two new UDP-Options that add support for
          requesting a datagram response be sent and to mark this datagram as
          a response to a request.</t>

          <t>XXX &lt;&lt; Future versions of the spec may define a parameter
          in an Option to indicate the EMTU_R to the peer.&gt;&gt;</t>

          <section anchor="UDPOPT-ECHOREQ" title="Echo Request Option">
            <t>The Echo Request Option allows a sending endpoint to solicit a
            response from a destination endpoint. The Echo Request carries a
            four byte token set by the sender.</t>

            <figure anchor="fig-echoreq" title="UDP ECHOREQ Option Format">
              <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=9  | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
            </figure>
          </section>

          <section anchor="UDPOPT-ECHORES" title="Echo Response Option">
            <t>The Echo Response Option is generated by the PL in response to
            reception of a previously received Echo Request. The Token field
            associates the response with the Token value carried in the most
            recently-received Echo Request. The rate of generation of UDP
            packets carrying an Echo Response Option MAY be rate-limited.</t>

            <figure anchor="fig-echores" title="UDP ECHORES Option Format">
              <artwork align="center"><![CDATA[
        +---------+--------+-----------------+
        | Kind=10 | Len=6  |     Token       |
        +---------+--------+-----------------+
          1 byte    1 byte       4 bytes       
]]></artwork>
            </figure>
          </section>
        </section>

        <section anchor="udpopt_probing"
                 title="Sending UDP-Option Probe Packets">
          <t>This method specifies a probe packet that does not carry an
          application data block. The probe packet consists of a UDP datagram
          header followed by a UDP Option containing the ECHOREQ option, which
          is followed by NOP Options to pad the remainder of the datagram
          payload to the probe size. NOP padding is used to control the length
          of the probe packet.</t>

          <t>A UDP Option carrying the ECHORES option is used to provide
          feedback when a probe packet is received at the destination
          endpoint.</t>
        </section>

        <section title="Validating the Path with UDP Options">
          <t>Since UDP is an unacknowledged PL, a sender that does not have
          higher-layer information confirming correct delivery of datagrams
          SHOULD implement the REACHABILITY_TIMER to periodically send probe
          packets while in the PROBE_DONE state.</t>
        </section>

        <section anchor="udpopt_ptb_handling"
                 title="Handling of PTB Messages by UDP">
          <t>Normal IMP verification MUST be performed as specified in Section
          5.2 of <xref target="RFC8085"></xref>. This requires that the PL
          verifies each received PTB messages to verify these are received in
          response to transmitted traffic. A verified PTB message MAY be used
          as input to the PLPMTUD algorithm.</t>
        </section>
      </section>

      <section title="SCTP">
        <t>Section 10.2 of <xref target="RFC4821"></xref> specifies a
        recommended PLPMTUD probing method for SCTP. It recommends the use of
        the PAD chunk, defined in <xref target="RFC4820"></xref> to be
        attached to a minimum length HEARTBEAT chunk to build a probe packet.
        This enables probing without affecting the transfer of user messages
        and without interfering with congestion control. This is preferred to
        using DATA chunks (with padding as required) as path probes.</t>

        <t>XXX &lt;&lt; Future versions of this specification might define a
        parameter contained in the INIT and INIT ACK chunk to indicate the MTU
        to the peer. However, multihoming makes this a bit complex, so it
        might not be worth doing.&gt;&gt;</t>

        <section anchor="sctp_over_ip" title="SCTP/IP4 and SCTP/IPv6">
          <t>The base protocol is specified in <xref
          target="RFC4960"></xref>.</t>

          <section anchor="sctp_over_ip_probing"
                   title="Sending SCTP Probe Packets">
            <t>Probe packets consist of an SCTP common header followed by a
            HEARTBEAT chunk and a PAD chunk. The PAD chunk is used to control
            the length of the probe packet. The HEARTBEAT chunk is used to
            trigger the sending of a HEARTBEAT ACK chunk. The reception of the
            HEARTBEAT ACK chunk acknowledges reception of a successful
            probe.</t>

            <t>The HEARTBEAT chunk carries a Heartbeat Information parameter
            which should include, besides the information suggested in <xref
            target="RFC4960"></xref>, the probing size, which is the MTU size
            the complete datagram will add up to. The size of the PAD chunk is
            therefore computed by reducing the probing size by the IPv4 or
            IPv6 header size, the SCTP common header, the HEARTBEAT request
            and the PAD chunk header. The payload of the PAD chunk contains
            arbitrary data.</t>

            <t>To avoid fragmentation of retransmitted data, probing starts
            right after the handshake, before data is sent. Assuming normal
            behaviour (i.e., the PMTU is smaller than or equal to the
            interface MTU), this process will take a few RTTs depending on the
            number of PMTU sizes probed. The Heartbeat timer can be used to
            implement the PROBE_TIMER.</t>
          </section>

          <section title="Validating the Path with SCTP">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_ip_ptb_handling"
                   title="PTB Message Handling by SCTP">
            <t>Normal IMP verification MUST be performed as specified in
            Appendix C of <xref target="RFC4960"></xref>. This requires that
            the first 8 bytes of the SCTP common header are quoted in the
            payload of the PTB message , which can be the case for ICMPv4 and
            is normally the case for ICMPv6. When the verification is
            completed, the router Link MTU indicated in the PTB message SHOULD
            be used with the PLPMTUD algorithm.</t>
          </section>
        </section>

        <section title="SCTP/UDP">
          <t>The UDP encapsulation of SCTP is specified in <xref
          target="RFC6951"></xref>.</t>

          <section anchor="sctp_over_udp_probing"
                   title="Sending SCTP/UDP Probe Packets">
            <t>Packet probing can be performed as specified in <xref
            target="sctp_over_ip_probing"></xref>. The maximum payload is
            reduced by 8 bytes, which has to be considered when filling the
            PAD chunk.</t>
          </section>

          <section title="Validating the Path with SCTP/UDP ">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_udp_ptb_handling"
                   title="Handling of PTB Messages by SCTP/UDP">
            <t>Normal IMP verification MUST be performed for PTB messages as
            specified in Appendix C of <xref target="RFC4960"></xref>. This
            requires that the first 8 bytes of the SCTP common header are
            contained in the PTB message, which can be the case for ICMPv4
            (but note the UDP header also consumes a part of the quoted packet
            header) and is normally the case for ICMPv6. When the verification
            is completed, the router Link MTU size indicated in the PTB
            message SHOULD be used with the PLPMTUD algorithm.</t>
          </section>
        </section>

        <section title="SCTP/DTLS">
          <t>The DTLS encapsulation of SCTP is specified in <xref
          target="I-D.ietf-tsvwg-sctp-dtls-encaps"></xref>. It is used for
          data channels in WebRTC implementations.</t>

          <section anchor="sctp_over_dtls_probing"
                   title="Sending SCTP/DTLS Probe Packets">
            <t>Packet probing can be done as specified in <xref
            target="sctp_over_ip_probing"></xref>.</t>
          </section>

          <section title="Validating the Path with SCTP/DTLS">
            <t>Since SCTP provides an acknowledged PL, a sender does MUST NOT
            implement the REACHABILITY_TIMER while in the PROBE_DONE
            state.</t>
          </section>

          <section anchor="sctp_over_dtls_ptb_handling"
                   title="Handling of PTB Messages by SCTP/DTLS">
            <t>It is not possible to perform normal IMP verification as
            specified in <xref target="RFC4960"></xref>, since even if the IMP
            contains enough information, the reflected SCTP common header
            would be encrypted. Therefore it is not possible to process PTB
            messages at the PL.</t>
          </section>
        </section>
      </section>

      <section title="Other IETF Transports">
        <t>QUIC is a UDP-based transport that provides reception feedback
        <xref target="I-D.ietf-quic-transport"></xref>.</t>

        <t>XXX &lt;&lt; This section will be completed in a future revision of
        this ID &gt;&gt;</t>
      </section>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>This work was partially funded by the European Union's Horizon 2020
      research and innovation programme under grant agreement No. 644334
      (NEAT). The views expressed are solely those of the author(s).</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>

      <t>If there are no requirements for IANA, the section will be removed
      during conversion into an RFC by the RFC Editor.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The security considerations for the use of UDP and SCTP are provided
      in the references RFCs. Security guidance for applications using UDP is
      provided in the UDP-Guidelines <xref target="RFC8085"></xref>.</t>

      <t>PTB messages could potentially be used to cause a node to
      inappropriately reduce the effective PMTU. A node supporting PLPMTUD
      SHOULD appropriately verify the payload of PTB messages to ensure these
      are received in response to transmitted traffic (i.e., a reported error
      condition that corresponds to a datagram actually sent by the path
      layer.</t>
    </section>
  </middle>

  <back>
    <!-- References split into informative and normative -->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC792;

      &RFC1122;

      &RFC1812;

      &RFC2119;

      &RFC2460;

      &RFC3828;

      &RFC8085;

      &RFC4820;

      &RFC4960;

      &RFC6951;

      &RFC8201;

      &I-D.ietf-tsvwg-udp-options;

      &I-D.ietf-tsvwg-sctp-dtls-encaps;

      &I-D.ietf-quic-transport;
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC1191;

      &RFC4821;

      &RFC2923;

      &RFC4340;

      &RFC4890;
    </references>

    <section anchor="StateChanges" title="Event-driven state changes">
      <t>This appendix contains an informative description of key events:</t>

      <t><list style="hanging">
          <t hangText="Path Setup:">When a new path is initiated, the state is
          set to PROBE_NONE. As soon as the path is confirmed, the state
          changes to PROBE_BASE and the probing mechanism for this path is
          started. A probe packet with the size of the BASE_PMTU is sent.</t>

          <t hangText="Arrival of an Acknowledgment:">Depending on the probing
          state, the reaction differs according to <xref
          target="fig-acks"></xref>, which is just a simplification of <xref
          target="fig-states"></xref> focusing on this event. <figure
              anchor="fig-acks"
              title="State changes at the arrival of an acknowledgment">
              <artwork align="center"><![CDATA[
+--------------+
|  PROBE_NONE  | --------------
+--------------+               \
                                \
+--------------+                 \
| PROBE_ERROR  | ---------------  \
+--------------+                \  \
                                 \  \
+--------------+                  \  \              +--------------+
|  PROBE_BASE  | --1----------     \  ------------> |  PROBE_BASE  |
+--------------+ --2-----     \     \               +--------------+
                         \     \     \
+--------------+          \     \     ------------> +--------------+
| PROBE_SEARCH | --2---    \     -----------------> | PROBE_SEARCH |
+--------------+ --1---\----\---------------------> +--------------+
                        \    \
+--------------+         \    \                     +--------------+
|  PROBE_DONE  |          \    -------------------> |  PROBE_DONE  |
+--------------+           -----------------------> +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum PMTU size has not yet been
              reached. Condition 2: The maximum PMTU size has been
              reached.</postamble>
            </figure></t>

          <t hangText="Probing timeout:">The PROBE_COUNT is initialised to
          zero each time the value of PROBED_SIZE is changed. The PROBE_TIMER
          is started each time a probe packet is sent. It is stopped when an
          acknowledgment arrives that confirms delivery of a probe packet. If
          the probe packet is not acknowledged before,the PROBE_TIMER expires,
          the PROBE_ERROR_COUNTER is incremented. When the PROBE_COUNT equals
          the value MAX_PROBES, the state is changed, otherwise a new probe
          packet of the same size (PROBED_SIZE) is resent. The state
          transitions are illustrated in <xref
          target="fig-probeTimer"></xref>. This shows a simplification of
          <xref target="fig-states"></xref> with a focus only on this event.
          <figure anchor="fig-probeTimer"
              title="State changes at the expiration of the probe timer">
              <artwork align="center"><![CDATA[
+--------------+
|  PROBE_NONE  |
+--------------+

+--------------+                                    +--------------+
| PROBE_ERROR  |                 -----------------> | PROBE_ERROR  |
+--------------+                /                   +--------------+
                               /
+--------------+ --2----------/                     +--------------+
|  PROBE_BASE  | --1------------------------------> |  PROBE_BASE  |
+--------------+                                    +--------------+

+--------------+                                    +--------------+
| PROBE_SEARCH | --1------------------------------> | PROBE_SEARCH |
+--------------+ --2---------                       +--------------+
                             \
+--------------+              \                     +--------------+
|  PROBE_DONE  |               -------------------> |  PROBE_DONE  |
+--------------+                                    +--------------+

]]></artwork>

              <postamble>Condition 1: The maximum number of probe packets has
              not been reached. Condition 2: The maximum number of probe
              packets has been reached.</postamble>
            </figure></t>

          <t hangText="PMTU raise timer timeout:">The path through the network
          can change over time. It impossible to discover whether a path
          change has increased in the actual PMTU by exchanging packets less
          than or equal to the effective PMTU. This requires PLPMTUD to
          periodically send a probe packet to detect whether a larger PMTU is
          possible. This probe packet is generated by the PMTU_RAISE_TIMER.
          When the timer expires, probing is restarted with the BASE_PMTU and
          the state is changed to PROBE_BASE.</t>

          <t hangText="Arrival of an ICMP message:">The active probing of the
          path can be supported by the arrival of PTB messages sent by routers
          or middleboxes with a link MTU that is smaller than the probe packet
          size. If the PTB message includes the router link MTU, three cases
          can be distinguished:</t>

          <t><list style="numbers">
              <t>The indicated link MTU in the PTB message is between the
              already probed and effective MTU and the probe that triggered
              the PTB message.</t>

              <t>The indicated link MTU in the PTB message is smaller than the
              effective PMTU.</t>

              <t>The indicated link MTU in the PTB message is equal to the
              BASE_PMTU.</t>
            </list></t>

          <t>In first case, the PROBE_BASE state transitions to the
          PROBE_ERROR state. In the PROBE_SEARCH state, a new probe packet is
          sent with the sized reported by the PTB message. Its result is
          handled according to the former events.</t>

          <t>The second case could be a result of a network re-configuration.
          If the reported link MTU in the PTB message is greater than the
          BASE_MTU, the probing starts again with a value of PROBE_BASE.
          Otherwise, the method enters the state PROBE_ERROR.</t>

          <t>In the third case, the maximum possible PMTU has been reached.
          This is probed again, because there could be a link further along
          the path with a still smaller MTU.</t>

          <t>Note: Not all routers include the link MTU size when they send a
          PTB message. If the PTB message does not indicate the link MTU, the
          probe is handled in the same way as condition 2 of <xref
          target="fig-probeTimer"></xref>.</t>
        </list></t>
    </section>

    <section title="Revision Notes">
      <t>Note to RFC-Editor: please remove this entire section prior to
      publication.</t>

      <t>Individual draft -00: <list style="symbols">
          <t hangText="Individual draft -00">Comments and corrections are
          welcome directly to the authors or via the IETF TSVWG working group
          mailing list.</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list>Individual draft -01:</t>

      <t><list style="symbols">
          <t hangText="Individual draft -00">Contains the first representation
          of the algorithm, showing the states and timers</t>

          <t hangText="Individual draft -00">The text describing when to set
          the effective PMTU has not yet been verified by the authors</t>

          <t hangText="Individual draft -00">The text describing how to handle
          a PTB message indicating a link MTU larger than the probe has yet
          not been verified by the authors</t>

          <t hangText="Individual draft -00">No text currently describes how
          to handle inconsistent results from arbitrary re-routing along
          different parallel paths</t>

          <t hangText="Individual draft -00">Some middleboxes lie about the
          MTU they report in PTB messages.</t>

          <t hangText="Individual draft -00">Some constants and times do not
          yet have recommended values</t>

          <t hangText="Individual draft -00">To determine security to
          off-path-attacks: We need to decide whether a received PTB message
          SHOULD be verified or MUST be verified?</t>

          <t hangText="Individual draft -00">This update is proposed for WG
          comments.</t>
        </list></t>
    </section>
  </back>
</rfc>
