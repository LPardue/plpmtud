diff --git a/sys/netinet/sctp_constants.h b/sys/netinet/sctp_constants.h
index dca34cc..a0044ed 100644
--- a/sys/netinet/sctp_constants.h
+++ b/sys/netinet/sctp_constants.h
@@ -700,7 +700,7 @@ __FBSDID("$FreeBSD$");
 
 #define SCTP_INITIAL_CWND 4380
 
-#define SCTP_DEFAULT_MTU 1500	/* emergency default MTU */
+#define SCTP_DEFAULT_MTU 1200	/* emergency default MTU */
 /* amount peer is obligated to have in rwnd or I will abort */
 #define SCTP_MIN_RWND	1500
 
@@ -717,6 +717,21 @@ __FBSDID("$FreeBSD$");
 #define SCTP_NUMBER_OF_SECRETS	8	/* or 8 * 4 = 32 octets */
 #define SCTP_SECRET_SIZE	32	/* number of octets in a 256 bits */
 
+/* Probing states */
+#define SCTP_PROBE_NONE                          0
+#define SCTP_PROBE_ERROR                         1
+#define SCTP_PROBE_BASE                          2
+#define SCTP_PROBE_SEARCH_UP                     3
+#define SCTP_PROBE_SEARCH_DOWN                   4
+#define SCTP_PROBE_DONE                          5
+
+#define SCTP_PROBE_MTU_V4_BASE                1200
+#define SCTP_PROBE_MTU_V6_BASE                1280
+
+#define SCTP_PROBE_MAX_PROBES                    2
+#define SCTP_PROBE_MIN                          76 /* Size of a HEARTBEAT Chunk with HB Info */
+
+#define SCTP_PROBE_UP                            1
 
 /*
  * SCTP upper layer notifications
@@ -816,6 +831,10 @@ __FBSDID("$FreeBSD$");
 #define SCTP_LOC_33 0x00000021
 #define SCTP_LOC_34 0x00000022
 #define SCTP_LOC_35 0x00000023
+#define SCTP_LOC_36 0x00000024
+#define SCTP_LOC_37 0x00000025
+#define SCTP_LOC_38 0x00000026
+#define SCTP_LOC_39 0x00000027
 
 
 /* Free assoc codes */
diff --git a/sys/netinet/sctp_header.h b/sys/netinet/sctp_header.h
index b650d93..9b20729 100644
--- a/sys/netinet/sctp_header.h
+++ b/sys/netinet/sctp_header.h
@@ -92,7 +92,8 @@ struct sctp_heartbeat_info_param {
 	uint8_t addr_family;
 	uint8_t addr_len;
 	/* make sure that this structure is 4 byte aligned */
-	uint8_t padding[2];
+	/* uint8_t padding[2]; */
+	uint16_t probe_mtu;
 	char address[SCTP_ADDRMAX];
 }                         SCTP_PACKED;
 
@@ -316,6 +317,12 @@ struct sctp_shutdown_ack_chunk {
 	struct sctp_chunkhdr ch;
 }                       SCTP_PACKED;
 
+/* Padding Chunk (PAD) */
+struct sctp_pad_chunk {
+	struct sctp_chunkhdr ch;
+	uint8_t padding_data;
+}		SCTP_PACKED;
+
 
 /* Operation Error (ERROR) */
 struct sctp_error_chunk {
diff --git a/sys/netinet/sctp_input.c b/sys/netinet/sctp_input.c
index 07d4e85..bed29b2 100644
--- a/sys/netinet/sctp_input.c
+++ b/sys/netinet/sctp_input.c
@@ -608,7 +608,7 @@ sctp_handle_heartbeat_ack(struct sctp_heartbeat_chunk *cp,
 	    (r_net->heartbeat_random1 == cp->heartbeat.hb_info.random_value1) &&
 	    (r_net->heartbeat_random2 == cp->heartbeat.hb_info.random_value2)) {
 		/*
-		 * If the its a HB and it's random value is correct when can
+		 * If it's a HB and its random value is correct we can
 		 * confirm the destination.
 		 */
 		r_net->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
@@ -689,6 +689,105 @@ sctp_handle_heartbeat_ack(struct sctp_heartbeat_chunk *cp,
 			    stcb->asoc.deleted_primary);
 		}
 	}
+	if (stcb->sctp_ep->plpmtud_supported) {
+		if (r_net->probing_state < SCTP_PROBE_BASE && !r_net->mtu_probing)
+			r_net->mtu_probing = 1;
+		if (r_net->mtu_probing) {
+			if (r_net->probe_counts > 0)
+				r_net->probe_counts = 0;
+			switch (r_net->probing_state) {
+			case SCTP_PROBE_NONE:
+				r_net->probing_state = SCTP_PROBE_BASE;
+				r_net->probed_mtu = SCTP_PROBE_MIN;
+#ifdef INET6
+				if (cp->heartbeat.hb_info.addr_family == AF_INET6) {
+					r_net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+				}
+#endif
+#ifdef INET
+				if (cp->heartbeat.hb_info.addr_family == AF_INET) {
+					r_net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+				}
+#endif
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_ERROR:
+				r_net->probed_mtu = SCTP_PROBE_MIN;
+				r_net->probe_mtu = sctp_get_next_mtu(SCTP_PROBE_MIN);
+				r_net->probing_state = SCTP_PROBE_SEARCH_UP;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_BASE:
+				r_net->probed_mtu = r_net->probe_mtu;
+				r_net->mtu = r_net->probe_mtu;
+				if (r_net->probed_mtu == r_net->max_mtu) {
+					sctp_pathmtu_adjustment(stcb, r_net->mtu);
+					r_net->mtu_probing = 0;
+					r_net->probing_state = SCTP_PROBE_DONE;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_7);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+					if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+							SCTP_FROM_SCTP_INPUT + SCTP_LOC_8);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+					break;
+				}
+				if (SCTP_PROBE_UP == 1) {
+					r_net->probing_state = SCTP_PROBE_SEARCH_UP;
+					r_net->probe_mtu = min(r_net->max_mtu, sctp_get_next_mtu(r_net->probed_mtu));
+				} else {
+					r_net->probing_state = SCTP_PROBE_SEARCH_DOWN;
+					r_net->probe_mtu = r_net->max_mtu;
+				}
+				sctp_pathmtu_adjustment(stcb, r_net->mtu);
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				r_net->probed_mtu = r_net->probe_mtu;
+				r_net->mtu = r_net->probe_mtu;
+				if (r_net->probed_mtu == r_net->max_mtu) {
+					sctp_pathmtu_adjustment(stcb, r_net->mtu);
+					r_net->mtu_probing = 0;
+					r_net->probing_state = SCTP_PROBE_DONE;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_9);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+					if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+							SCTP_FROM_SCTP_INPUT + SCTP_LOC_10);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+					break;
+				}
+				uint32_t next_mtu = sctp_get_next_mtu(net->mtu);
+
+				if (next_mtu > r_net->probe_mtu)
+					r_net->probe_mtu = next_mtu;
+				if (next_mtu > r_net->max_mtu) {
+					r_net->probe_mtu = r_net->max_mtu;
+				}
+				sctp_pathmtu_adjustment(stcb, r_net->probe_mtu);
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN: /* Highest MTU reached. Stop Probing */
+				r_net->probed_mtu = r_net->probe_mtu;
+				r_net->mtu = r_net->probe_mtu;
+				sctp_pathmtu_adjustment(stcb, r_net->mtu);
+				r_net->mtu_probing = 0;
+				r_net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_11);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+				if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+						SCTP_FROM_SCTP_INPUT + SCTP_LOC_12);
+				}
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_DONE:
+				break;
+			}
+		}
+	}
 }
 
 static int
@@ -796,7 +895,7 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 	}
 	/* stop any receive timers */
 	sctp_timer_stop(SCTP_TIMER_TYPE_RECV, stcb->sctp_ep, stcb, net,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_7);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_13);
 	/* notify user of the abort and clean up... */
 	sctp_abort_notification(stcb, 1, error, abort, SCTP_SO_NOT_LOCKED);
 	/* free the tcb */
@@ -818,7 +917,7 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 #endif
 	stcb->asoc.state |= SCTP_STATE_WAS_ABORTED;
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_8);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_14);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -842,8 +941,28 @@ sctp_start_net_timers(struct sctp_tcb *stcb)
 		sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 		if ((net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
 		    (cnt_hb_sent < SCTP_BASE_SYSCTL(sctp_hb_maxburst))) {
+			if (stcb->asoc.plpmtud_supported) {
+				net->probing_state = SCTP_PROBE_NONE;
+				net->probe_mtu = 0;
+			}
 			sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
 			cnt_hb_sent++;
+		} else if (stcb->asoc.plpmtud_supported) {
+			net->probing_state = SCTP_PROBE_BASE;
+#ifdef INET6
+			if (stcb->asoc.scope.ipv6_addr_legal) {
+				net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+			}
+#endif
+#ifdef INET
+			if (stcb->asoc.scope.ipv4_addr_legal) {
+				net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+			}
+#endif
+			net->probed_mtu = SCTP_PROBE_MIN;
+			net->mtu_probing = 1;
+			net->probe_counts = 0;
+			sctp_send_a_probe(stcb->sctp_ep, stcb, net);
 		}
 	}
 	if (cnt_hb_sent) {
@@ -955,7 +1074,7 @@ sctp_handle_shutdown(struct sctp_shutdown_chunk *cp,
 		 * SHUTDOWN-ACK-SENT.
 		 */
 		sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWN, stcb->sctp_ep, stcb,
-		    net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_9);
+		    net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_15);
 	}
 	/* Now is there unsent data on a stream somewhere? */
 	some_on_streamwheel = sctp_is_there_unsent_data(stcb, SCTP_SO_NOT_LOCKED);
@@ -1052,7 +1171,7 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 #endif
 	/* stop the timer */
 	sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWN, stcb->sctp_ep, stcb, net,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_10);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_16);
 	/* send SHUTDOWN-COMPLETE */
 	sctp_send_shutdown_complete(stcb, net, 0);
 	/* notify upper layer protocol */
@@ -1073,7 +1192,7 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 	atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_11);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_17);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -1232,7 +1351,7 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_12);
+					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_18);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -1584,10 +1703,10 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 			/* we have already processed the INIT so no problem */
 			sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp,
 			    stcb, net,
-			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_13);
+			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_19);
 			sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp,
 			    stcb, net,
-			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_14);
+			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_20);
 			/* update current state */
 			if (SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_ECHOED)
 				SCTP_STAT_INCR_COUNTER32(sctps_activeestab);
@@ -1746,7 +1865,7 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 		if (how_indx < sizeof(asoc->cookie_how))
 			asoc->cookie_how[how_indx] = 8;
 		sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_15);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_21);
 		sctp_stop_all_cookie_timers(stcb);
 		/*
 		 * since we did not send a HB make sure we don't double
@@ -1889,9 +2008,9 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 		if (how_indx < sizeof(asoc->cookie_how))
 			asoc->cookie_how[how_indx] = 12;
 		sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp, stcb, net,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_16);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_22);
 		sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_17);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_23);
 
 		/* notify upper layer */
 		*notification = SCTP_NOTIFY_ASSOC_RESTART;
@@ -2162,7 +2281,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_18);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_24);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2194,7 +2313,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_19);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_25);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2212,7 +2331,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_20);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_26);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2242,7 +2361,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 			atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 			(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_21);
+			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_27);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 			SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2292,7 +2411,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_22);
+		    SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2769,7 +2888,7 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 				atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 #endif
 				(void)sctp_free_assoc(*inp_p, *stcb, SCTP_NORMAL_PROC,
-				    SCTP_FROM_SCTP_INPUT + SCTP_LOC_23);
+				    SCTP_FROM_SCTP_INPUT + SCTP_LOC_29);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 				SCTP_SOCKET_UNLOCK(pcb_so, 1);
 #endif
@@ -2801,6 +2920,7 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 			inp->reconfig_supported = (*inp_p)->reconfig_supported;
 			inp->nrsack_supported = (*inp_p)->nrsack_supported;
 			inp->pktdrop_supported = (*inp_p)->pktdrop_supported;
+			inp->plpmtud_supported = (*inp_p)->plpmtud_supported;
 			inp->partial_delivery_point = (*inp_p)->partial_delivery_point;
 			inp->sctp_context = (*inp_p)->sctp_context;
 			inp->local_strreset_support = (*inp_p)->local_strreset_support;
@@ -3201,7 +3321,7 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 #endif
 	/* stop the timer */
 	sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWNACK, stcb->sctp_ep, stcb, net,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_24);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_30);
 	SCTP_STAT_INCR_COUNTER32(sctps_shutdown);
 	/* free the TCB */
 	SCTPDBG(SCTP_DEBUG_INPUT2,
@@ -3215,7 +3335,7 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 	atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_25);
+	    SCTP_FROM_SCTP_INPUT + SCTP_LOC_31);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -3324,7 +3444,7 @@ process_chunk_drop(struct sctp_tcb *stcb, struct sctp_chunk_desc *desc,
 				/* restart the timer */
 				sctp_timer_stop(SCTP_TIMER_TYPE_SEND, stcb->sctp_ep,
 				    stcb, tp1->whoTo,
-				    SCTP_FROM_SCTP_INPUT + SCTP_LOC_26);
+				    SCTP_FROM_SCTP_INPUT + SCTP_LOC_32);
 				sctp_timer_start(SCTP_TIMER_TYPE_SEND, stcb->sctp_ep,
 				    stcb, tp1->whoTo);
 
@@ -3393,7 +3513,7 @@ process_chunk_drop(struct sctp_tcb *stcb, struct sctp_chunk_desc *desc,
 			 */
 			sctp_timer_stop(SCTP_TIMER_TYPE_INIT, stcb->sctp_ep,
 			    stcb, net,
-			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_27);
+			    SCTP_FROM_SCTP_INPUT + SCTP_LOC_33);
 			sctp_send_initiate(stcb->sctp_ep, stcb, SCTP_SO_NOT_LOCKED);
 		}
 		break;
@@ -3596,7 +3716,7 @@ sctp_clean_up_stream_reset(struct sctp_tcb *stcb)
 	asoc = &stcb->asoc;
 
 	sctp_timer_stop(SCTP_TIMER_TYPE_STRRESET, stcb->sctp_ep, stcb,
-	    chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
+	    chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_34);
 	TAILQ_REMOVE(&asoc->control_send_queue,
 	    chk,
 	    sctp_next);
@@ -4880,7 +5000,7 @@ process_control_chunks:
 						atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 						(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-						    SCTP_FROM_SCTP_INPUT + SCTP_LOC_29);
+						    SCTP_FROM_SCTP_INPUT + SCTP_LOC_35);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 						SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -5313,7 +5433,7 @@ process_control_chunks:
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_30);
+					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_36);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -5493,7 +5613,7 @@ process_control_chunks:
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_31);
+					    SCTP_FROM_SCTP_INPUT + SCTP_LOC_37);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
diff --git a/sys/netinet/sctp_output.c b/sys/netinet/sctp_output.c
index 2baaef8..2f604b3 100644
--- a/sys/netinet/sctp_output.c
+++ b/sys/netinet/sctp_output.c
@@ -7055,6 +7055,7 @@ sctp_clean_up_ctl(struct sctp_tcb *stcb, struct sctp_association *asoc, int so_l
 		    (chk->rec.chunk_id.id == SCTP_NR_SELECTIVE_ACK) ||	/* EY */
 		    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) ||
 		    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_ACK) ||
+		    (chk->rec.chunk_id.id == SCTP_PAD_CHUNK) ||
 		    (chk->rec.chunk_id.id == SCTP_FORWARD_CUM_TSN) ||
 		    (chk->rec.chunk_id.id == SCTP_SHUTDOWN) ||
 		    (chk->rec.chunk_id.id == SCTP_SHUTDOWN_ACK) ||
@@ -8370,6 +8371,12 @@ again_one_more_time:
 				}
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
+				if (((chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) || (chk->rec.chunk_id.id == SCTP_PAD_CHUNK)) &&
+				    (inp->plpmtud_supported && net->mtu_probing)) {
+					mtu = net->probe_mtu;
+				} else {
+					mtu = 0;
+				}
 				if (mtu > (chk->send_size + omtu))
 					mtu -= (chk->send_size + omtu);
 				else
@@ -8386,6 +8393,7 @@ again_one_more_time:
 				    (chk->rec.chunk_id.id == SCTP_NR_SELECTIVE_ACK) ||	/* EY */
 				    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) ||
 				    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_ACK) ||
+				    (chk->rec.chunk_id.id == SCTP_PAD_CHUNK) ||
 				    (chk->rec.chunk_id.id == SCTP_SHUTDOWN) ||
 				    (chk->rec.chunk_id.id == SCTP_SHUTDOWN_ACK) ||
 				    (chk->rec.chunk_id.id == SCTP_OPERATION_ERROR) ||
@@ -11403,6 +11411,11 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net, int so_locked
 		return;
 		break;
 	}
+	if (stcb->sctp_ep->plpmtud_supported && net->mtu_probing) {
+		hb->heartbeat.hb_info.probe_mtu = net->probe_mtu;
+	} else {
+		hb->heartbeat.hb_info.probe_mtu = 0;
+	}
 	net->hb_responded = 0;
 	TAILQ_INSERT_TAIL(&stcb->asoc.control_send_queue, chk, sctp_next);
 	stcb->asoc.ctrl_queue_cnt++;
@@ -11410,6 +11423,56 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net, int so_locked
 	return;
 }
 
+void sctp_send_pad(struct sctp_tcb *stcb, struct sctp_nets *net, uint16_t pad_size)
+{
+	struct sctp_tmit_chunk *chk;
+	struct sctp_pad_chunk *pad;
+
+	SCTP_TCB_LOCK_ASSERT(stcb);
+	KASSERT(pad_size >= 4, ("%s: padsize %u too small", __FUNCTION__, pad_size));
+	KASSERT(pad_size <= 2048, ("%s: padsize %u too large", __FUNCTION__, pad_size));
+	KASSERT(pad_size % 4 == 0, ("%s: padsize %u not aligned", __FUNCTION__, pad_size));
+	KASSERT(net->mtu_probing != 0, ("%s: mtu_probing not enabled", __FUNCTION__));
+	if (net == NULL) {
+		return;
+	}
+	sctp_alloc_a_chunk(stcb, chk);
+	if (chk == NULL) {
+		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Gak, can't get a chunk for pad\n");
+		return;
+	}
+	chk->copy_by_ref = 0;
+	chk->rec.chunk_id.id = SCTP_PAD_CHUNK;
+	chk->rec.chunk_id.can_take_data = 1;
+	chk->flags = 0;
+	chk->asoc = &stcb->asoc;
+
+	if (net->mtu_probing) {
+		chk->send_size = pad_size;
+	}
+	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
+	if (chk->data == NULL) {
+		/* no mbufs */
+		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
+		return;
+	}
+	SCTP_BUF_LEN(chk->data) = chk->send_size;
+	chk->sent = SCTP_DATAGRAM_UNSENT;
+	chk->snd_count = 0;
+	chk->whoTo = net;
+	atomic_add_int(&chk->whoTo->ref_count, 1);
+	pad = mtod(chk->data, struct sctp_pad_chunk *);
+	memset(pad, 0, chk->send_size);
+	pad->ch.chunk_type = SCTP_PAD_CHUNK;
+	pad->ch.chunk_flags = 0;
+	pad->ch.chunk_length = htons(chk->send_size);
+	net->hb_responded = 0;
+	TAILQ_INSERT_TAIL(&stcb->asoc.control_send_queue, chk, sctp_next);
+	stcb->asoc.ctrl_queue_cnt++;
+	return;
+}
+
+
 void
 sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
     uint32_t high_tsn)
diff --git a/sys/netinet/sctp_output.h b/sys/netinet/sctp_output.h
index 32f968c..3152046 100644
--- a/sys/netinet/sctp_output.h
+++ b/sys/netinet/sctp_output.h
@@ -72,7 +72,7 @@ int
 int
     sctp_v4src_match_nexthop(struct sctp_ifa *sifa, sctp_route_t *ro);
 
-void 
+void
 sctp_send_initiate(struct sctp_inpcb *, struct sctp_tcb *, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
     SCTP_UNUSED
@@ -115,7 +115,7 @@ void sctp_send_shutdown_ack(struct sctp_tcb *, struct sctp_nets *);
 
 void sctp_send_shutdown_complete(struct sctp_tcb *, struct sctp_nets *, int);
 
-void 
+void
 sctp_send_shutdown_complete2(struct sockaddr *, struct sockaddr *,
     struct sctphdr *,
     uint8_t, uint32_t, uint16_t,
@@ -144,13 +144,13 @@ int
 sctp_output(struct sctp_inpcb *, struct mbuf *, struct sockaddr *,
     struct mbuf *, struct thread *, int);
 
-void 
+void
 sctp_chunk_output(struct sctp_inpcb *, struct sctp_tcb *, int, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
     SCTP_UNUSED
 #endif
 );
-void 
+void
 sctp_send_abort_tcb(struct sctp_tcb *, struct mbuf *, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
     SCTP_UNUSED
@@ -163,6 +163,8 @@ void sctp_send_sack(struct sctp_tcb *, int);
 
 void sctp_send_hb(struct sctp_tcb *, struct sctp_nets *, int);
 
+void sctp_send_pad(struct sctp_tcb *, struct sctp_nets *, uint16_t send_size);
+
 void sctp_send_ecn_echo(struct sctp_tcb *, struct sctp_nets *, uint32_t);
 
 
@@ -199,7 +201,7 @@ sctp_send_abort(struct mbuf *, int, struct sockaddr *, struct sockaddr *,
     uint8_t, uint32_t, uint16_t,
     uint32_t, uint16_t);
 
-void 
+void
 sctp_send_operr_to(struct sockaddr *, struct sockaddr *,
     struct sctphdr *, uint32_t, struct mbuf *,
     uint8_t, uint32_t, uint16_t,
diff --git a/sys/netinet/sctp_pcb.c b/sys/netinet/sctp_pcb.c
index d9abbf9..df41d29 100644
--- a/sys/netinet/sctp_pcb.c
+++ b/sys/netinet/sctp_pcb.c
@@ -2458,6 +2458,7 @@ sctp_inpcb_alloc(struct socket *so, uint32_t vrf_id)
 	inp->reconfig_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_reconfig_enable);
 	inp->nrsack_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_nrsack_enable);
 	inp->pktdrop_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pktdrop_enable);
+	inp->plpmtud_supported = (uint8_t) SCTP_BASE_SYSCTL(sctp_plpmtud_enable);
 	inp->idata_supported = 0;
 
 	inp->fibnum = so->so_fibnum;
@@ -3896,6 +3897,11 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 	net->RTO_measured = 0;
 	stcb->asoc.numnets++;
 	net->ref_count = 1;
+	if (stcb->asoc.plpmtud_supported) {
+		net->probe_mtu = 0;
+		net->mtu_probing = 0;
+		net->probing_state = SCTP_PROBE_NONE;
+	}
 	net->cwr_window_tsn = net->last_cwr_tsn = stcb->asoc.sending_seq - 1;
 	net->port = port;
 	net->dscp = stcb->asoc.default_dscp;
@@ -3962,7 +3968,15 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 				 */
 				SCTP_SET_MTU_OF_ROUTE(&net->ro._l_addr.sa,
 				    net->ro.ro_rt, net->mtu);
+			}  else {
+				if (stcb->asoc.plpmtud_supported) {
+					net->mtu = min(rmtu, SCTP_DEFAULT_MTU);
+				} else {
+					net->mtu = rmtu;
+				}
 			}
+			if (stcb->asoc.plpmtud_supported)
+				net->max_mtu = max(net->mtu, rmtu);
 		}
 	}
 	if (net->mtu == 0) {
@@ -4090,6 +4104,29 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		TAILQ_INSERT_HEAD(&stcb->asoc.nets,
 		    stcb->asoc.primary_destination, sctp_next);
 	}
+	if (stcb->asoc.plpmtud_supported) {
+		net->probing_state = SCTP_PROBE_NONE;
+		net->probe_mtu = 0;
+		/*if ((from == (SCTP_ALLOC_ASOC | SCTP_IN_COOKIE_PROC))
+		    || !(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {*/
+		if (from == SCTP_ADDR_DYNAMIC_ADDED) {
+			net->probing_state = SCTP_PROBE_BASE;
+#ifdef INET
+		if (newaddr->sa_family == AF_INET) {
+			net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+		}
+#endif
+#ifdef INET6
+		if (newaddr->sa_family == AF_INET6) {
+			net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+		}
+#endif
+		net->probed_mtu = SCTP_PROBE_MIN;
+		net->mtu_probing = 1;
+		net->probe_counts = 0;
+		sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+		}
+	}
 	return (0);
 }
 
diff --git a/sys/netinet/sctp_pcb.h b/sys/netinet/sctp_pcb.h
index 86fae1f..1003e11 100644
--- a/sys/netinet/sctp_pcb.h
+++ b/sys/netinet/sctp_pcb.h
@@ -414,6 +414,7 @@ struct sctp_inpcb {
 	uint8_t reconfig_supported;
 	uint8_t nrsack_supported;
 	uint8_t pktdrop_supported;
+	uint8_t plpmtud_supported;
 	struct sctp_nonpad_sndrcvinfo def_send;
 	/*-
 	 * These three are here for the sosend_dgram
@@ -525,7 +526,7 @@ void sctp_free_ifn(struct sctp_ifn *sctp_ifnp);
 void sctp_free_ifa(struct sctp_ifa *sctp_ifap);
 
 
-void 
+void
 sctp_del_addr_from_vrf(uint32_t vrfid, struct sockaddr *addr,
     uint32_t ifn_index, const char *if_name);
 
@@ -535,7 +536,7 @@ struct sctp_nets *sctp_findnet(struct sctp_tcb *, struct sockaddr *);
 
 struct sctp_inpcb *sctp_pcb_findep(struct sockaddr *, int, int, uint32_t);
 
-int 
+int
 sctp_inpcb_bind(struct socket *, struct sockaddr *,
     struct sctp_ifa *, struct thread *);
 
diff --git a/sys/netinet/sctp_peeloff.c b/sys/netinet/sctp_peeloff.c
index b702476..ad6e4bd 100644
--- a/sys/netinet/sctp_peeloff.c
+++ b/sys/netinet/sctp_peeloff.c
@@ -125,6 +125,7 @@ sctp_do_peeloff(struct socket *head, struct socket *so, sctp_assoc_t assoc_id)
 	n_inp->reconfig_supported = inp->reconfig_supported;
 	n_inp->nrsack_supported = inp->nrsack_supported;
 	n_inp->pktdrop_supported = inp->pktdrop_supported;
+	n_inp->plpmtud_supported = inp->plpmtud_supported;
 	n_inp->partial_delivery_point = inp->partial_delivery_point;
 	n_inp->sctp_context = inp->sctp_context;
 	n_inp->max_cwnd = inp->max_cwnd;
diff --git a/sys/netinet/sctp_structs.h b/sys/netinet/sctp_structs.h
index f737174..a7e1710 100644
--- a/sys/netinet/sctp_structs.h
+++ b/sys/netinet/sctp_structs.h
@@ -384,6 +384,12 @@ struct sctp_nets {
 	uint8_t rto_needed;
 	uint32_t flowid;
 	uint8_t flowtype;
+	uint32_t probe_mtu; /* actual mtu probing size */
+	uint32_t probed_mtu; /* mtu that has last been probed */
+	uint32_t max_mtu;
+	uint16_t probe_counts; /* Counter for the probing attempts */
+	uint16_t probing_state;
+	uint8_t mtu_probing; /* Flag to indicate whether mtu_probing should be processed */
 };
 
 
@@ -1187,6 +1193,7 @@ struct sctp_association {
 	uint8_t reconfig_supported;
 	uint8_t nrsack_supported;
 	uint8_t pktdrop_supported;
+	uint8_t plpmtud_supported;
 	uint8_t idata_supported;
 
 	/* Did the peer make the stream config (add out) request */
diff --git a/sys/netinet/sctp_sysctl.c b/sys/netinet/sctp_sysctl.c
index 50d9da6..81f2263 100644
--- a/sys/netinet/sctp_sysctl.c
+++ b/sys/netinet/sctp_sysctl.c
@@ -63,6 +63,7 @@ sctp_init_sysctls()
 	SCTP_BASE_SYSCTL(sctp_reconfig_enable) = SCTPCTL_RECONFIG_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_nrsack_enable) = SCTPCTL_NRSACK_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_pktdrop_enable) = SCTPCTL_PKTDROP_ENABLE_DEFAULT;
+	SCTP_BASE_SYSCTL(sctp_plpmtud_enable) = SCTPCTL_PLPMTUD_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_peer_chunk_oh) = SCTPCTL_PEER_CHKOH_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_max_burst_default) = SCTPCTL_MAXBURST_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_fr_max_burst_default) = SCTPCTL_FRMAXBURST_DEFAULT;
@@ -868,6 +869,7 @@ SYSCTL_PROC(_net_inet_sctp, OID_AUTO, asconf_enable, CTLFLAG_VNET | CTLTYPE_UINT
 SCTP_UINT_SYSCTL(reconfig_enable, sctp_reconfig_enable, SCTPCTL_RECONFIG_ENABLE)
 SCTP_UINT_SYSCTL(nrsack_enable, sctp_nrsack_enable, SCTPCTL_NRSACK_ENABLE)
 SCTP_UINT_SYSCTL(pktdrop_enable, sctp_pktdrop_enable, SCTPCTL_PKTDROP_ENABLE)
+SCTP_UINT_SYSCTL(plpmtud_enable, sctp_plpmtud_enable, SCTPCTL_PLPMTUD_ENABLE)
 SCTP_UINT_SYSCTL(peer_chkoh, sctp_peer_chunk_oh, SCTPCTL_PEER_CHKOH)
 SCTP_UINT_SYSCTL(maxburst, sctp_max_burst_default, SCTPCTL_MAXBURST)
 SCTP_UINT_SYSCTL(fr_maxburst, sctp_fr_max_burst_default, SCTPCTL_FRMAXBURST)
diff --git a/sys/netinet/sctp_sysctl.h b/sys/netinet/sctp_sysctl.h
index 959bd1e..730da8b 100644
--- a/sys/netinet/sctp_sysctl.h
+++ b/sys/netinet/sctp_sysctl.h
@@ -51,6 +51,7 @@ struct sctp_sysctl {
 	uint32_t sctp_reconfig_enable;
 	uint32_t sctp_nrsack_enable;
 	uint32_t sctp_pktdrop_enable;
+	uint32_t sctp_plpmtud_enable;
 	uint32_t sctp_fr_max_burst_default;
 	uint32_t sctp_peer_chunk_oh;
 	uint32_t sctp_max_burst_default;
@@ -191,6 +192,12 @@ struct sctp_sysctl {
 #define SCTPCTL_PKTDROP_ENABLE_MAX	1
 #define SCTPCTL_PKTDROP_ENABLE_DEFAULT	0
 
+/* plpmtud_enable: Enable Packetization Layer Path MTU Discovery */
+#define SCTPCTL_PLPMTUD_ENABLE_DESC	"Enable Packetization Layer PMTU Discovery"
+#define SCTPCTL_PLPMTUD_ENABLE_MIN	0
+#define SCTPCTL_PLPMTUD_ENABLE_MAX	1
+#define SCTPCTL_PLPMTUD_ENABLE_DEFAULT	0
+
 /* loopback_nocsum: Enable NO Csum on packets sent on loopback */
 #define SCTPCTL_LOOPBACK_NOCSUM_DESC	"Enable NO Csum on packets sent on loopback"
 #define SCTPCTL_LOOPBACK_NOCSUM_MIN	0
diff --git a/sys/netinet/sctp_timer.c b/sys/netinet/sctp_timer.c
index 4c87ee6..1acd4d8 100644
--- a/sys/netinet/sctp_timer.c
+++ b/sys/netinet/sctp_timer.c
@@ -1442,7 +1442,70 @@ sctp_heartbeat_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		} else {
 			ms_gone_by = 0xffffffff;
 		}
-		if ((ms_gone_by >= net->heart_beat_delay) ||
+
+		if (inp->plpmtud_supported && net->mtu_probing) {
+			uint32_t base;
+			if ((++net->probe_counts < SCTP_PROBE_MAX_PROBES)
+			    && net->probing_state > SCTP_PROBE_ERROR
+			    && net->probing_state < SCTP_PROBE_DONE) {
+				sctp_send_a_probe(inp, stcb, net);
+			} else {
+				switch (net->probing_state) {
+				case SCTP_PROBE_BASE:
+					net->probe_counts = 0;
+					net->probed_mtu = SCTP_PROBE_MIN;
+					net->mtu_probing = 0;
+					net->probing_state = SCTP_PROBE_ERROR;
+					net->mtu = SCTP_PROBE_MIN;
+					sctp_pathmtu_adjustment(stcb, net->mtu);
+					sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+					break;
+				case SCTP_PROBE_SEARCH_UP:
+					net->probe_counts = 0;
+					net->mtu_probing = 0;
+					net->mtu = net->probed_mtu;
+					net->probing_state = SCTP_PROBE_DONE;
+					sctp_pathmtu_adjustment(stcb, net->mtu);
+					break;
+				case SCTP_PROBE_SEARCH_DOWN:
+					net->max_mtu = sctp_get_prev_mtu(net->max_mtu);
+#ifdef INET6
+					if (stcb->asoc.scope.ipv6_addr_legal) {
+						base = SCTP_PROBE_MTU_V6_BASE;
+					}
+#endif
+#ifdef INET
+					if (stcb->asoc.scope.ipv4_addr_legal) {
+						base = SCTP_PROBE_MTU_V4_BASE;
+					}
+#endif
+					if ((net->max_mtu > base) && (sctp_get_next_mtu(base) != net->max_mtu)) {
+						net->probe_mtu = sctp_get_next_mtu(base);
+						net->probe_counts = 0;
+						net->probing_state = SCTP_PROBE_SEARCH_UP;
+						sctp_send_a_probe(inp, stcb, net);
+					} else if (net->max_mtu == base) {
+						net->probe_mtu = base;
+						net->probe_counts = 0;
+						net->probing_state = SCTP_PROBE_BASE;
+						sctp_send_a_probe(inp, stcb, net);
+					} else if (net->max_mtu < base) {
+						net->probe_counts = 0;
+						net->probed_mtu = SCTP_PROBE_MIN;
+						net->mtu_probing = 0;
+						net->probing_state = SCTP_PROBE_ERROR;
+						net->mtu = SCTP_PROBE_MIN;
+						sctp_pathmtu_adjustment(stcb, net->mtu);
+						sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+					} else {
+						net->probe_mtu = net->max_mtu;
+						net->probe_counts = 0;
+						sctp_send_a_probe(inp, stcb, net);
+					}
+					break;
+				}
+			}
+		} else if ((ms_gone_by >= net->heart_beat_delay) ||
 		    (net->dest_state & SCTP_ADDR_PF)) {
 			sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
 		}
@@ -1455,59 +1518,119 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
     struct sctp_tcb *stcb,
     struct sctp_nets *net)
 {
-	uint32_t next_mtu, mtu;
-
-	next_mtu = sctp_get_next_mtu(net->mtu);
-
-	if ((next_mtu > net->mtu) && (net->port == 0)) {
-		if ((net->src_addr_selected == 0) ||
-		    (net->ro._s_addr == NULL) ||
-		    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
-			if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
-				sctp_free_ifa(net->ro._s_addr);
-				net->ro._s_addr = NULL;
-				net->src_addr_selected = 0;
-			} else if (net->ro._s_addr == NULL) {
+	uint32_t next_mtu = 0, mtu = 0;
+
+	if (inp->plpmtud_supported) {
+		if (net->probing_state == SCTP_PROBE_DONE) {
+			net->mtu_probing = 1;
+			net->probe_mtu = net->mtu;
+			net->probing_state = SCTP_PROBE_BASE;
+			net->probe_counts = 0;
+			mtu = net->mtu;
+			if ((net->src_addr_selected == 0) ||
+				(net->ro._s_addr == NULL) ||
+				(net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+				if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+					sctp_free_ifa(net->ro._s_addr);
+					net->ro._s_addr = NULL;
+					net->src_addr_selected = 0;
+				} else if (net->ro._s_addr == NULL) {
 #if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
-				if (net->ro._l_addr.sa.sa_family == AF_INET6) {
-					struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
 
-					/* KAME hack: embed scopeid */
-					(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
+						/* KAME hack: embed scopeid */
+						(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
+					}
+#endif
+net->ro._s_addr = sctp_source_address_selection(inp,
+						stcb,
+						(sctp_route_t *) & net->ro,
+						net, 0, stcb->asoc.vrf_id);
+	#if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+
+						(void)sa6_recoverscope(sin6);
+					}
+#endif				/* INET6 */
+				}
+				if (net->ro._s_addr)
+					net->src_addr_selected = 1;
+			}
+			if (net->ro._s_addr) {
+				mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
+#if defined(INET) || defined(INET6)
+				if (net->port) {
+					mtu -= sizeof(struct udphdr);
 				}
 #endif
+				net->max_mtu = max(mtu, net->max_mtu);
+			}
+			sctp_send_a_probe(inp, stcb, net);
+			/*	if (mtu > next_mtu) {
+					net->mtu = next_mtu;
+				}
+			} else {
+				net->mtu = mtu;
+			}*/
+		} else {
+		/* restart the timer */
+			sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
+		}
+	} else {
+		next_mtu = sctp_get_next_mtu(net->mtu);
+
+		if ((next_mtu > net->mtu) && (net->port == 0)) {
+			if ((net->src_addr_selected == 0) ||
+			    (net->ro._s_addr == NULL) ||
+			    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+				if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+					sctp_free_ifa(net->ro._s_addr);
+					net->ro._s_addr = NULL;
+					net->src_addr_selected = 0;
+				} else if (net->ro._s_addr == NULL) {
+#if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
 
-				net->ro._s_addr = sctp_source_address_selection(inp,
-				    stcb,
-				    (sctp_route_t *)&net->ro,
-				    net, 0, stcb->asoc.vrf_id);
+						/* KAME hack: embed scopeid */
+						(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
+					}
+#endif
+
+					net->ro._s_addr = sctp_source_address_selection(inp,
+					    stcb,
+					    (sctp_route_t *)&net->ro,
+					    net, 0, stcb->asoc.vrf_id);
 #if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
-				if (net->ro._l_addr.sa.sa_family == AF_INET6) {
-					struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
 
-					(void)sa6_recoverscope(sin6);
-				}
+						(void)sa6_recoverscope(sin6);
+					}
 #endif				/* INET6 */
+				}
+				if (net->ro._s_addr)
+					net->src_addr_selected = 1;
 			}
-			if (net->ro._s_addr)
-				net->src_addr_selected = 1;
-		}
-		if (net->ro._s_addr) {
-			mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
+			if (net->ro._s_addr) {
+				mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
 #if defined(INET) || defined(INET6)
-			if (net->port) {
-				mtu -= sizeof(struct udphdr);
-			}
+				if (net->port) {
+					mtu -= sizeof(struct udphdr);
+				}
 #endif
-			if (mtu > next_mtu) {
-				net->mtu = next_mtu;
-			} else {
-				net->mtu = mtu;
+				if (mtu > next_mtu) {
+					net->mtu = next_mtu;
+				} else {
+					net->mtu = mtu;
+				}
 			}
 		}
+		/* restart the timer */
+		sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 	}
-	/* restart the timer */
-	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 }
 
 void
diff --git a/sys/netinet/sctp_usrreq.c b/sys/netinet/sctp_usrreq.c
index 1d1a805..a48c010 100644
--- a/sys/netinet/sctp_usrreq.c
+++ b/sys/netinet/sctp_usrreq.c
@@ -107,6 +107,7 @@ sctp_pathmtu_adjustment(struct sctp_tcb *stcb, uint16_t nxtsz)
 
 	/* Adjust that too */
 	stcb->asoc.smallest_mtu = nxtsz;
+	printf("%s:%d: set smallest_mtu to %d\n", __func__, __LINE__, stcb->asoc.smallest_mtu);
 	/* now off to subtract IP_DF flag if needed */
 	overhead = IP_HDR_SIZE + sizeof(struct sctphdr);
 	if (sctp_auth_is_required_chunk(SCTP_DATA, stcb->asoc.peer_auth_chunks)) {
@@ -195,13 +196,164 @@ sctp_notify(struct sctp_inpcb *inp,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_2);
+		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_1);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 		/* SCTP_TCB_UNLOCK(stcb); MT: I think this is not needed. */
 #endif
 		/* no need to unlock here, since the TCB is gone */
 	} else if (icmp_code == ICMP_UNREACH_NEEDFRAG) {
+		/* Stop the PMTU timer. */
+		if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+			timer_stopped = 1;
+			sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
+			    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_2);
+		}
+	}
+	/* Adjust destination size limit */
+	if (inp->plpmtud_supported) {
+		uint32_t base;
+#ifdef INET6
+		if (stcb->asoc.scope.ipv6_addr_legal) {
+			base = SCTP_PROBE_MTU_V6_BASE;
+		}
+#endif
+#ifdef INET
+		if (stcb->asoc.scope.ipv4_addr_legal) {
+			base = SCTP_PROBE_MTU_V4_BASE;
+		}
+#endif
+		net->probe_counts = 0;
+		if (net->probing_state == SCTP_PROBE_DONE) {
+			sctp_pathmtu_timer(inp, stcb, net);
+		}
+		if (net->probing_state > SCTP_PROBE_NONE && net->probing_state < SCTP_PROBE_DONE) {
+		if (next_mtu == 0) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu_probing = 0;
+				net->mtu = net->probed_mtu;
+				net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_3);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+				if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_4);
+				}
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->max_mtu = sctp_get_prev_mtu(net->max_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			}
+		} else if (net->probed_mtu <= next_mtu && next_mtu < net->probe_mtu) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu_probing = 0;
+				net->mtu = net->probed_mtu;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			}
+		} else if (next_mtu < net->probed_mtu) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				if (next_mtu < base) {
+					net->probed_mtu = SCTP_PROBE_MIN;
+					net->mtu_probing = 0;
+					net->max_mtu = min(net->max_mtu, next_mtu);
+					net->probing_state = SCTP_PROBE_ERROR;
+					sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				} else {
+					net->probe_mtu = base;
+					net->probed_mtu = base;
+					net->mtu = min(net->probed_mtu, next_mtu);
+					net->max_mtu = min(net->max_mtu, next_mtu);
+					net->probing_state = SCTP_PROBE_BASE;
+					net->probe_counts = 0;
+					sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				}
+				break;
+			}
+		} else if (next_mtu == base) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->mtu_probing = 0;
+				net->mtu = next_mtu;
+				net->probed_mtu = next_mtu;
+				net->max_mtu = next_mtu;
+				net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_5);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+				if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_6);
+				}
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu = min(net->probed_mtu, next_mtu);
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				if (net->probed_mtu > base) {
+					net->probe_mtu = base;
+					net->probing_state = SCTP_PROBE_BASE;
+					net->probe_counts = 0;
+					sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				} else {
+					net->probing_state = SCTP_PROBE_DONE;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_7);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+					if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+						SCTP_FROM_SCTP_USRREQ + SCTP_LOC_8);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				}
+				break;
+			}
+		}
+		SCTP_TCB_UNLOCK(stcb);
+	}
+	else {
 		/* Find the next (smaller) MTU */
 		if (next_mtu == 0) {
 			/*
@@ -211,25 +363,20 @@ sctp_notify(struct sctp_inpcb *inp,
 			 */
 			next_mtu = sctp_get_prev_mtu(ip_len);
 		}
-		/* Stop the PMTU timer. */
-		if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
-			timer_stopped = 1;
-			sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-			    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_1);
-		} else {
-			timer_stopped = 0;
-		}
+
 		/* Update the path MTU. */
 		if (net->port) {
 			next_mtu -= sizeof(struct udphdr);
 		}
 		if (net->mtu > next_mtu) {
 			net->mtu = next_mtu;
+#if defined(__FreeBSD__)
 			if (net->port) {
 				sctp_hc_set_mtu(&net->ro._l_addr, inp->fibnum, next_mtu + sizeof(struct udphdr));
 			} else {
 				sctp_hc_set_mtu(&net->ro._l_addr, inp->fibnum, next_mtu);
 			}
+#endif
 		}
 		/* Update the association MTU */
 		if (stcb->asoc.smallest_mtu > next_mtu) {
@@ -240,8 +387,7 @@ sctp_notify(struct sctp_inpcb *inp,
 			sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 		}
 		SCTP_TCB_UNLOCK(stcb);
-	} else {
-		SCTP_TCB_UNLOCK(stcb);
+		}
 	}
 }
 
@@ -723,7 +869,7 @@ sctp_disconnect(struct socket *so)
 					SCTP_STAT_DECR_GAUGE32(sctps_currestab);
 				}
 				(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-				    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_3);
+				    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_9);
 				/* No unlock tcb assoc is gone */
 				return (0);
 			}
@@ -790,7 +936,7 @@ sctp_disconnect(struct socket *so)
 
 			abort_anyway:
 					op_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, "");
-					stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_4;
+					stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_10;
 					sctp_send_abort_tcb(stcb, op_err, SCTP_SO_LOCKED);
 					SCTP_STAT_INCR_COUNTER32(sctps_aborted);
 					if ((SCTP_GET_STATE(&stcb->asoc) == SCTP_STATE_OPEN) ||
@@ -799,7 +945,7 @@ sctp_disconnect(struct socket *so)
 					}
 					SCTP_INP_RUNLOCK(inp);
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_5);
+					    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_11);
 					return (0);
 				} else {
 					sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_CLOSING, SCTP_SO_LOCKED);
@@ -972,7 +1118,7 @@ sctp_shutdown(struct socket *so)
 
 		abort_anyway:
 				op_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, "");
-				stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_6;
+				stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12;
 				sctp_abort_an_association(stcb->sctp_ep, stcb,
 				    op_err, SCTP_SO_LOCKED);
 				SCTP_INP_RUNLOCK(inp);
@@ -1483,7 +1629,7 @@ sctp_do_connect_x(struct socket *so, struct sctp_inpcb *inp, void *optval,
 	/* Fill in the return id */
 	if (error) {
 		(void)sctp_free_assoc(inp, stcb, SCTP_PCBFREE_FORCE,
-		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_7);
+		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
 		goto out_now;
 	}
 	a_id = (sctp_assoc_t *)optval;
@@ -4877,7 +5023,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				(void)SCTP_GETTIME_TIMEVAL(&stcb->asoc.time_entered);
 				sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp, stcb,
 				    stcb->asoc.primary_destination,
-				    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_8);
+				    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_14);
 				sctp_send_initiate(inp, stcb, SCTP_SO_LOCKED);
 			} else {
 				/*
@@ -5280,7 +5426,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
 						    !(net->dest_state & SCTP_ADDR_NOHB)) {
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_9);
+							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_15);
 						}
 						net->dest_state |= SCTP_ADDR_NOHB;
 					}
@@ -5291,7 +5437,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->heart_beat_delay = 0;
 						}
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-						    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_10);
+						    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_16);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 						net->dest_state &= ~SCTP_ADDR_NOHB;
 					}
@@ -5304,7 +5450,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					if ((paddrp->spp_flags & SPP_PMTUD_DISABLE) && (paddrp->spp_pathmtu >= SCTP_SMALLEST_PMTU)) {
 						if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 							sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_11);
+							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
 						}
 						net->dest_state |= SCTP_ADDR_NO_PMTUD;
 						net->mtu = paddrp->spp_pathmtu;
@@ -5344,7 +5490,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								    stcb->sctp_ep, stcb, net,
-								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12);
+								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
 						}
@@ -5389,7 +5535,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 									sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 									sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 									    stcb->sctp_ep, stcb, net,
-									    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
+									    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_19);
 									sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 								}
 							}
@@ -5424,7 +5570,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								net->dest_state &= ~SCTP_ADDR_NOHB;
 							}
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_14);
+							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_20);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 						}
 						sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
@@ -5436,7 +5582,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {
 									sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 									    inp, stcb, net,
-									    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_15);
+									    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_21);
 								}
 							}
 						}
@@ -5446,7 +5592,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 							if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 								sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_16);
+								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_22);
 							}
 							net->dest_state |= SCTP_ADDR_NO_PMTUD;
 							net->mtu = paddrp->spp_pathmtu;
@@ -6323,7 +6469,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 							    stcb->sctp_ep, stcb, net,
-							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
+							    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_23);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
 					}
@@ -6354,7 +6500,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								    stcb->sctp_ep, stcb, net,
-								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
+								    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_24);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
 						}
@@ -7264,7 +7410,7 @@ sctp_accept(struct socket *so, struct sockaddr **addr)
 	if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 		SCTP_TCB_LOCK(stcb);
 		sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_19);
+		    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_25);
 	}
 	return (0);
 }
diff --git a/sys/netinet/sctputil.c b/sys/netinet/sctputil.c
index f61a3ed..9ca920b 100644
--- a/sys/netinet/sctputil.c
+++ b/sys/netinet/sctputil.c
@@ -770,7 +770,7 @@ static uint32_t sctp_mtu_sizes[] = {
 	1492,
 	1500,
 	1536,
-	2002,
+	2000,
 	2048,
 	4352,
 	4464,
@@ -797,7 +797,7 @@ sctp_get_prev_mtu(uint32_t val)
 			break;
 		}
 	}
-	return (sctp_mtu_sizes[i - 1]);
+	return (sctp_mtu_sizes[i - 1] - sctp_mtu_sizes[i - 1] % 4);
 }
 
 /*
@@ -811,8 +811,8 @@ sctp_get_next_mtu(uint32_t val)
 	uint32_t i;
 
 	for (i = 0; i < (sizeof(sctp_mtu_sizes) / sizeof(uint32_t)); i++) {
-		if (val < sctp_mtu_sizes[i]) {
-			return (sctp_mtu_sizes[i]);
+		if (val < sctp_mtu_sizes[i] - sctp_mtu_sizes[i] % 4) {
+			return (sctp_mtu_sizes[i] - sctp_mtu_sizes[i] % 4);
 		}
 	}
 	return (val);
@@ -978,6 +978,7 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	asoc->reconfig_supported = inp->reconfig_supported;
 	asoc->nrsack_supported = inp->nrsack_supported;
 	asoc->pktdrop_supported = inp->pktdrop_supported;
+	asoc->plpmtud_supported = inp->plpmtud_supported;
 	asoc->idata_supported = inp->idata_supported;
 	asoc->sctp_cmt_pf = (uint8_t)0;
 	asoc->sctp_frag_point = inp->sctp_frag_point;
@@ -2059,7 +2060,8 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				to_ticks = to_ticks - jitter;
 			}
 			if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
-			    !(net->dest_state & SCTP_ADDR_PF)) {
+			    !(net->dest_state & SCTP_ADDR_PF) &&
+			    !(net->mtu_probing)) {
 				to_ticks += net->heart_beat_delay;
 			}
 			/*
@@ -6132,7 +6134,7 @@ sctp_m_free(struct mbuf *m)
 	return (m_free(m));
 }
 
-void 
+void
 sctp_m_freem(struct mbuf *mb)
 {
 	while (mb != NULL)
@@ -7326,3 +7328,48 @@ sctp_hc_get_mtu(union sctp_sockstore *addr, uint16_t fibnum)
 	}
 	return ((uint32_t)tcp_hc_getmtu(&inc));
 }
+
+void
+sctp_send_a_probe(struct sctp_inpcb *inp,
+    struct sctp_tcb *stcb,
+    struct sctp_nets *net)
+{
+	int ovh, sum_probe_chunks;
+	uint16_t send_size;
+
+	if (!net->mtu_probing && net->probing_state > SCTP_PROBE_NONE) {
+		net->mtu_probing = 1;
+		net->probe_counts = 0;
+	}
+	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {
+		ovh = SCTP_MIN_OVERHEAD;
+	} else {
+		ovh = SCTP_MIN_V4_OVERHEAD;
+	}
+#if defined(INET) || defined(INET6)
+	if (net->port) {
+		net->probe_mtu -= sizeof(struct udphdr);
+	}
+#endif
+	sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+	sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTPUTIL + SCTP_LOC_11);
+	sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+	if (net->probe_mtu > 0) {
+		sum_probe_chunks = net->probe_mtu - ovh - sizeof(struct sctp_heartbeat_info_param) - sizeof(struct sctp_chunkhdr);
+		while (sum_probe_chunks > 0) {
+			if (sum_probe_chunks > 2048) {
+				send_size = 2048;
+			} else {
+				send_size = sum_probe_chunks;
+			}
+			sctp_send_pad(stcb, net, send_size);
+			sum_probe_chunks -= send_size;
+		}
+	}
+	sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_HB_TMR, SCTP_SO_NOT_LOCKED);
+	if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+		sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
+		    SCTP_FROM_SCTPUTIL + SCTP_LOC_12);
+	}
+	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+}
diff --git a/sys/netinet/sctputil.h b/sys/netinet/sctputil.h
index 97b3365..2ea1c0a 100644
--- a/sys/netinet/sctputil.h
+++ b/sys/netinet/sctputil.h
@@ -151,7 +151,7 @@ struct mbuf *
 struct mbuf *
      sctp_pad_lastmbuf(struct mbuf *, int, struct mbuf *);
 
-void 
+void
 sctp_ulp_notify(uint32_t, struct sctp_tcb *, uint32_t, void *, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
     SCTP_UNUSED
@@ -166,7 +166,7 @@ sctp_pull_off_control_to_new_inp(struct sctp_inpcb *old_inp,
 
 void sctp_stop_timers_for_shutdown(struct sctp_tcb *);
 
-void 
+void
 sctp_report_all_outbound(struct sctp_tcb *, uint16_t, int, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
     SCTP_UNUSED
@@ -175,7 +175,7 @@ sctp_report_all_outbound(struct sctp_tcb *, uint16_t, int, int
 
 int sctp_expand_mapping_array(struct sctp_association *, uint32_t);
 
-void 
+void
 sctp_abort_notification(struct sctp_tcb *, uint8_t, uint16_t,
     struct sctp_abort_chunk *, int
 #if !defined(__APPLE__) && !defined(SCTP_SO_LOCK_TESTING)
@@ -201,7 +201,7 @@ sctp_abort_an_association(struct sctp_inpcb *, struct sctp_tcb *,
 #endif
 );
 
-void 
+void
 sctp_handle_ootb(struct mbuf *, int, int,
     struct sockaddr *, struct sockaddr *,
     struct sctphdr *, struct sctp_inpcb *,
@@ -209,7 +209,7 @@ sctp_handle_ootb(struct mbuf *, int, int,
     uint8_t, uint32_t, uint16_t,
     uint32_t, uint16_t);
 
-int 
+int
 sctp_connectx_helper_add(struct sctp_tcb *stcb, struct sockaddr *addr,
     int totaddr, int *error);
 
@@ -245,6 +245,9 @@ int sctp_cmpaddr(struct sockaddr *, struct sockaddr *);
 
 void sctp_print_address(struct sockaddr *);
 
+void
+sctp_send_a_probe(struct sctp_inpcb *inp, struct sctp_tcb *stcb, struct sctp_nets *net);
+
 int
 sctp_release_pr_sctp_chunk(struct sctp_tcb *, struct sctp_tmit_chunk *,
     uint8_t, int
@@ -256,11 +259,11 @@ sctp_release_pr_sctp_chunk(struct sctp_tcb *, struct sctp_tmit_chunk *,
 struct mbuf *sctp_generate_cause(uint16_t, char *);
 struct mbuf *sctp_generate_no_user_data_cause(uint32_t);
 
-void 
+void
 sctp_bindx_add_address(struct socket *so, struct sctp_inpcb *inp,
     struct sockaddr *sa, sctp_assoc_t assoc_id,
     uint32_t vrf_id, int *error, void *p);
-void 
+void
 sctp_bindx_delete_address(struct sctp_inpcb *inp,
     struct sockaddr *sa, sctp_assoc_t assoc_id,
     uint32_t vrf_id, int *error);
