diff --git a/netinet/sctp_constants.h b/netinet/sctp_constants.h
index 9afc9bd..b6cba8d 100755
--- a/netinet/sctp_constants.h
+++ b/netinet/sctp_constants.h
@@ -720,7 +720,7 @@ extern void getwintimeofday(struct timeval *tv);
 
 #define SCTP_INITIAL_CWND 4380
 
-#define SCTP_DEFAULT_MTU 1500 /* emergency default MTU */
+#define SCTP_DEFAULT_MTU 1200	/* emergency default MTU */
 /* amount peer is obligated to have in rwnd or I will abort */
 #define SCTP_MIN_RWND	1500
 
@@ -737,6 +737,21 @@ extern void getwintimeofday(struct timeval *tv);
 #define SCTP_NUMBER_OF_SECRETS	8	/* or 8 * 4 = 32 octets */
 #define SCTP_SECRET_SIZE	32	/* number of octets in a 256 bits */
 
+/* Probing states */
+#define SCTP_PROBE_NONE                          0
+#define SCTP_PROBE_ERROR                         1
+#define SCTP_PROBE_BASE                          2
+#define SCTP_PROBE_SEARCH_UP                     3
+#define SCTP_PROBE_SEARCH_DOWN                   4
+#define SCTP_PROBE_DONE                          5
+
+#define SCTP_PROBE_MTU_V4_BASE                1200
+#define SCTP_PROBE_MTU_V6_BASE                1280
+
+#define SCTP_PROBE_MAX_PROBES                    2
+#define SCTP_PROBE_MIN                          76 /* Size of a HEARTBEAT Chunk with HB Info */
+
+#define SCTP_PROBE_UP                            1
 
 /*
  * SCTP upper layer notifications
@@ -836,6 +851,10 @@ extern void getwintimeofday(struct timeval *tv);
 #define SCTP_LOC_33 0x00000021
 #define SCTP_LOC_34 0x00000022
 #define SCTP_LOC_35 0x00000023
+#define SCTP_LOC_36 0x00000024
+#define SCTP_LOC_37 0x00000025
+#define SCTP_LOC_38 0x00000026
+#define SCTP_LOC_39 0x00000027
 
 
 /* Free assoc codes */
diff --git a/netinet/sctp_header.h b/netinet/sctp_header.h
index 20031e9..4cd6654 100755
--- a/netinet/sctp_header.h
+++ b/netinet/sctp_header.h
@@ -104,7 +104,8 @@ struct sctp_heartbeat_info_param {
 	uint8_t addr_family;
 	uint8_t addr_len;
 	/* make sure that this structure is 4 byte aligned */
-	uint8_t padding[2];
+	/* uint8_t padding[2]; */
+	uint16_t probe_mtu;
 	char address[SCTP_ADDRMAX];
 } SCTP_PACKED;
 
@@ -335,6 +336,11 @@ struct sctp_shutdown_ack_chunk {
 	struct sctp_chunkhdr ch;
 } SCTP_PACKED;
 
+/* Padding Chunk (PAD) */
+struct sctp_pad_chunk {
+	struct sctp_chunkhdr ch;
+	uint8_t padding_data;
+} SCTP_PACKED;
 
 /* Operation Error (ERROR) */
 struct sctp_error_chunk {
@@ -485,10 +491,10 @@ struct sctp_stream_reset_response_tsn {
 } SCTP_PACKED;
 
 struct sctp_stream_reset_add_strm {
-  struct sctp_paramhdr ph;
-  uint32_t request_seq;
-  uint16_t number_of_streams;
-  uint16_t reserved;
+	struct sctp_paramhdr ph;
+	uint32_t request_seq;
+	uint16_t number_of_streams;
+	uint16_t reserved;
 } SCTP_PACKED;
 
 #define SCTP_STREAM_RESET_RESULT_NOTHING_TO_DO   0x00000000 /* XXX: unused */
diff --git a/netinet/sctp_input.c b/netinet/sctp_input.c
index 0649ec2..9cc418f 100755
--- a/netinet/sctp_input.c
+++ b/netinet/sctp_input.c
@@ -766,6 +766,105 @@ sctp_handle_heartbeat_ack(struct sctp_heartbeat_chunk *cp,
 					stcb->asoc.deleted_primary);
 		}
 	}
+	if (stcb->sctp_ep->plpmtud_supported) {
+		if (r_net->probing_state < SCTP_PROBE_BASE && !r_net->mtu_probing)
+			r_net->mtu_probing = 1;
+		if (r_net->mtu_probing) {
+			if (r_net->probe_counts > 0)
+				r_net->probe_counts = 0;
+			switch (r_net->probing_state) {
+			case SCTP_PROBE_NONE:
+				r_net->probing_state = SCTP_PROBE_BASE;
+				r_net->probed_mtu = SCTP_PROBE_MIN;
+#ifdef INET6
+				if (cp->heartbeat.hb_info.addr_family == AF_INET6) {
+					r_net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+				}
+#endif
+#ifdef INET
+				if (cp->heartbeat.hb_info.addr_family == AF_INET) {
+					r_net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+				}
+#endif
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_ERROR:
+				r_net->probed_mtu = SCTP_PROBE_MIN;
+				r_net->probe_mtu = sctp_get_next_mtu(SCTP_PROBE_MIN);
+				r_net->probing_state = SCTP_PROBE_SEARCH_UP;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_BASE:
+				r_net->probed_mtu = r_net->probe_mtu;
+				if (r_net->probed_mtu == r_net->max_mtu) {
+					sctp_pathmtu_adjustment(stcb, r_net->mtu);
+					r_net->mtu_probing = 0;
+					r_net->probing_state = SCTP_PROBE_DONE;
+					r_net->mtu = r_net->max_mtu;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_7);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+					if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+							SCTP_FROM_SCTP_INPUT + SCTP_LOC_8);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+					break;
+				}
+				if (SCTP_PROBE_UP == 1) {
+					r_net->probing_state = SCTP_PROBE_SEARCH_UP;
+					r_net->probe_mtu = min(r_net->max_mtu, sctp_get_next_mtu(r_net->probed_mtu));
+				} else {
+					r_net->probing_state = SCTP_PROBE_SEARCH_DOWN;
+					r_net->probe_mtu = r_net->max_mtu;
+				}
+				sctp_pathmtu_adjustment(stcb, r_net->mtu);
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				r_net->probed_mtu = r_net->probe_mtu;
+				if (r_net->probed_mtu == r_net->max_mtu) {
+					r_net->mtu = r_net->max_mtu;
+					sctp_pathmtu_adjustment(stcb, r_net->mtu);
+					r_net->mtu_probing = 0;
+					r_net->probing_state = SCTP_PROBE_DONE;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_9);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+					if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+							SCTP_FROM_SCTP_INPUT + SCTP_LOC_10);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+					break;
+				}
+				uint32_t next_mtu = sctp_get_next_mtu(r_net->probed_mtu);
+
+				if (next_mtu > r_net->probe_mtu)
+					r_net->probe_mtu = next_mtu;
+				if (next_mtu > r_net->max_mtu) {
+					r_net->probe_mtu = r_net->max_mtu;
+				}
+				sctp_pathmtu_adjustment(stcb, r_net->probe_mtu);
+				sctp_send_a_probe(stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN: /* Highest MTU reached. Stop Probing */
+				r_net->probed_mtu = r_net->probe_mtu;
+				r_net->mtu = r_net->probe_mtu;
+				sctp_pathmtu_adjustment(stcb, r_net->mtu);
+				r_net->mtu_probing = 0;
+				r_net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_11);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, r_net);
+				if (SCTP_OS_TIMER_PENDING(&r_net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net,
+						SCTP_FROM_SCTP_INPUT + SCTP_LOC_12);
+				}
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, r_net);
+				break;
+			case SCTP_PROBE_DONE:
+				break;
+			}
+		}
+	}
 }
 
 static int
@@ -866,7 +965,7 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 	}
 	/* stop any receive timers */
 	sctp_timer_stop(SCTP_TIMER_TYPE_RECV, stcb->sctp_ep, stcb, net,
-	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_7);
+	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_13);
 	/* notify user of the abort and clean up... */
 	sctp_abort_notification(stcb, 1, error, abort, SCTP_SO_NOT_LOCKED);
 	/* free the tcb */
@@ -888,7 +987,7 @@ sctp_handle_abort(struct sctp_abort_chunk *abort,
 #endif
 	stcb->asoc.state |= SCTP_STATE_WAS_ABORTED;
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-			      SCTP_FROM_SCTP_INPUT + SCTP_LOC_8);
+			      SCTP_FROM_SCTP_INPUT + SCTP_LOC_14);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -914,8 +1013,28 @@ sctp_start_net_timers(struct sctp_tcb *stcb)
 		sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 		if ((net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
 		    (cnt_hb_sent < SCTP_BASE_SYSCTL(sctp_hb_maxburst))) {
+			if (stcb->asoc.plpmtud_supported) {
+				net->probing_state = SCTP_PROBE_NONE;
+				net->probe_mtu = 0;
+			}
 			sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
 			cnt_hb_sent++;
+		} else if (stcb->asoc.plpmtud_supported) {
+			net->probing_state = SCTP_PROBE_BASE;
+#ifdef INET6
+			if (stcb->asoc.scope.ipv6_addr_legal) {
+				net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+			}
+#endif
+#ifdef INET
+			if (stcb->asoc.scope.ipv4_addr_legal) {
+				net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+			}
+#endif
+			net->probed_mtu = SCTP_PROBE_MIN;
+			net->mtu_probing = 1;
+			net->probe_counts = 0;
+			sctp_send_a_probe(stcb->sctp_ep, stcb, net);
 		}
 	}
 	if (cnt_hb_sent) {
@@ -1024,7 +1143,7 @@ sctp_handle_shutdown(struct sctp_shutdown_chunk *cp,
 		 * SHUTDOWN-ACK-SENT.
 		 */
 		sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWN, stcb->sctp_ep, stcb,
-		                net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_9);
+		                net, SCTP_FROM_SCTP_INPUT + SCTP_LOC_15);
 	}
 	/* Now is there unsent data on a stream somewhere? */
 	some_on_streamwheel = sctp_is_there_unsent_data(stcb, SCTP_SO_NOT_LOCKED);
@@ -1121,7 +1240,7 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 #endif
 	/* stop the timer */
 	sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWN, stcb->sctp_ep, stcb, net,
-	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_10);
+	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_16);
 	/* send SHUTDOWN-COMPLETE */
 	sctp_send_shutdown_complete(stcb, net, 0);
 	/* notify upper layer protocol */
@@ -1142,7 +1261,7 @@ sctp_handle_shutdown_ack(struct sctp_shutdown_ack_chunk *cp SCTP_UNUSED,
 	atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-			      SCTP_FROM_SCTP_INPUT + SCTP_LOC_11);
+			      SCTP_FROM_SCTP_INPUT + SCTP_LOC_17);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -1301,7 +1420,7 @@ sctp_handle_error(struct sctp_chunkhdr *ch,
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-							      SCTP_FROM_SCTP_INPUT + SCTP_LOC_12);
+							      SCTP_FROM_SCTP_INPUT + SCTP_LOC_18);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -1673,10 +1792,10 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 				/* we have already processed the INIT so no problem */
 				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp,
 				                stcb, net,
-				                SCTP_FROM_SCTP_INPUT + SCTP_LOC_13);
+				                SCTP_FROM_SCTP_INPUT + SCTP_LOC_19);
 				sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp,
 				                stcb, net,
-				                SCTP_FROM_SCTP_INPUT + SCTP_LOC_14);
+				                SCTP_FROM_SCTP_INPUT + SCTP_LOC_20);
 				/* update current state */
 				if (SCTP_GET_STATE(asoc) == SCTP_STATE_COOKIE_ECHOED)
 					SCTP_STAT_INCR_COUNTER32(sctps_activeestab);
@@ -1835,7 +1954,7 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 		if (how_indx < sizeof(asoc->cookie_how))
 			asoc->cookie_how[how_indx] = 8;
 		sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_15);
+		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_21);
 		sctp_stop_all_cookie_timers(stcb);
 		/*
 		 * since we did not send a HB make sure we don't double
@@ -1977,9 +2096,9 @@ sctp_process_cookie_existing(struct mbuf *m, int iphlen, int offset,
 		if (how_indx < sizeof(asoc->cookie_how))
 			asoc->cookie_how[how_indx] = 12;
 		sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp, stcb, net,
-		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_16);
+		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_22);
 		sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_17);
+		                SCTP_FROM_SCTP_INPUT + SCTP_LOC_23);
 
 		/* notify upper layer */
 		*notification = SCTP_NOTIFY_ASSOC_RESTART;
@@ -2268,7 +2387,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-				      SCTP_FROM_SCTP_INPUT + SCTP_LOC_18);
+				      SCTP_FROM_SCTP_INPUT + SCTP_LOC_24);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2300,7 +2419,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_19);
+		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_25);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2318,7 +2437,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_20);
+		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_26);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2348,7 +2467,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 			atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 			(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-			                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_21);
+			                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_27);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 			SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2414,7 +2533,7 @@ sctp_process_cookie_new(struct mbuf *m, int iphlen, int offset,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_22);
+		                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -2950,7 +3069,7 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 				atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 #endif
 				(void)sctp_free_assoc(*inp_p, *stcb, SCTP_NORMAL_PROC,
-				                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_23);
+				                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_29);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 				SCTP_SOCKET_UNLOCK(pcb_so, 1);
 #endif
@@ -2982,6 +3101,7 @@ sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
 			inp->reconfig_supported = (*inp_p)->reconfig_supported;
 			inp->nrsack_supported = (*inp_p)->nrsack_supported;
 			inp->pktdrop_supported = (*inp_p)->pktdrop_supported;
+			inp->plpmtud_supported = (*inp_p)->plpmtud_supported;
 			inp->partial_delivery_point = (*inp_p)->partial_delivery_point;
 			inp->sctp_context = (*inp_p)->sctp_context;
 			inp->local_strreset_support = (*inp_p)->local_strreset_support;
@@ -3384,7 +3504,7 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 #endif
 	/* stop the timer */
 	sctp_timer_stop(SCTP_TIMER_TYPE_SHUTDOWNACK, stcb->sctp_ep, stcb, net,
-	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_24);
+	                SCTP_FROM_SCTP_INPUT + SCTP_LOC_30);
 	SCTP_STAT_INCR_COUNTER32(sctps_shutdown);
 	/* free the TCB */
 	SCTPDBG(SCTP_DEBUG_INPUT2,
@@ -3398,7 +3518,7 @@ sctp_handle_shutdown_complete(struct sctp_shutdown_complete_chunk *cp SCTP_UNUSE
 	atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 	(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
-	                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_25);
+	                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_31);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -3507,7 +3627,7 @@ process_chunk_drop(struct sctp_tcb *stcb, struct sctp_chunk_desc *desc,
 			/* restart the timer */
 			sctp_timer_stop(SCTP_TIMER_TYPE_SEND, stcb->sctp_ep,
 					stcb, tp1->whoTo,
-			                SCTP_FROM_SCTP_INPUT + SCTP_LOC_26);
+			                SCTP_FROM_SCTP_INPUT + SCTP_LOC_32);
 			sctp_timer_start(SCTP_TIMER_TYPE_SEND, stcb->sctp_ep,
 					 stcb, tp1->whoTo);
 
@@ -3576,7 +3696,7 @@ process_chunk_drop(struct sctp_tcb *stcb, struct sctp_chunk_desc *desc,
 			 */
 			sctp_timer_stop(SCTP_TIMER_TYPE_INIT, stcb->sctp_ep,
 					stcb, net,
-			                SCTP_FROM_SCTP_INPUT + SCTP_LOC_27);
+			                SCTP_FROM_SCTP_INPUT + SCTP_LOC_33);
 			sctp_send_initiate(stcb->sctp_ep, stcb, SCTP_SO_NOT_LOCKED);
 		}
 		break;
@@ -3776,7 +3896,7 @@ sctp_clean_up_stream_reset(struct sctp_tcb *stcb)
 	asoc = &stcb->asoc;
 
 	sctp_timer_stop(SCTP_TIMER_TYPE_STRRESET, stcb->sctp_ep, stcb,
-	                chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_28);
+	                chk->whoTo, SCTP_FROM_SCTP_INPUT + SCTP_LOC_34);
 	TAILQ_REMOVE(&asoc->control_send_queue,
 	    chk,
 	    sctp_next);
@@ -5072,7 +5192,7 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 						atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 						(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-						                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_29);
+						                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_35);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 						SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -5508,7 +5628,7 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_30);
+					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_36);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
@@ -5689,7 +5809,7 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_31);
+					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_37);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
diff --git a/netinet/sctp_output.c b/netinet/sctp_output.c
index 90b0bf3..cd6ce2a 100755
--- a/netinet/sctp_output.c
+++ b/netinet/sctp_output.c
@@ -7552,6 +7552,7 @@ sctp_clean_up_ctl(struct sctp_tcb *stcb, struct sctp_association *asoc, int so_l
 		    (chk->rec.chunk_id.id == SCTP_NR_SELECTIVE_ACK) ||	/* EY */
 		    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) ||
 		    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_ACK) ||
+		    (chk->rec.chunk_id.id == SCTP_PAD_CHUNK) ||
 		    (chk->rec.chunk_id.id == SCTP_FORWARD_CUM_TSN) ||
 		    (chk->rec.chunk_id.id == SCTP_SHUTDOWN) ||
 		    (chk->rec.chunk_id.id == SCTP_SHUTDOWN_ACK) ||
@@ -8874,6 +8875,12 @@ again_one_more_time:
 				}
 				SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 				/* update our MTU size */
+				if (((chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) || (chk->rec.chunk_id.id == SCTP_PAD_CHUNK)) &&
+				    (inp->plpmtud_supported && net->mtu_probing)) {
+					mtu = net->probe_mtu;
+				} else {
+					mtu = 0;
+				}
 				if (mtu > (chk->send_size + omtu))
 					mtu -= (chk->send_size + omtu);
 				else
@@ -8890,6 +8897,7 @@ again_one_more_time:
 				    (chk->rec.chunk_id.id == SCTP_NR_SELECTIVE_ACK) || /* EY */
 				    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_REQUEST) ||
 				    (chk->rec.chunk_id.id == SCTP_HEARTBEAT_ACK) ||
+				    (chk->rec.chunk_id.id == SCTP_PAD_CHUNK) ||
 				    (chk->rec.chunk_id.id == SCTP_SHUTDOWN) ||
 				    (chk->rec.chunk_id.id == SCTP_SHUTDOWN_ACK) ||
 				    (chk->rec.chunk_id.id == SCTP_OPERATION_ERROR) ||
@@ -10700,7 +10708,7 @@ do_it_again:
 			 */
 			un_sent = stcb->asoc.total_output_queue_size - stcb->asoc.total_flight;
 			if ((un_sent < (int)(stcb->asoc.smallest_mtu - SCTP_MIN_OVERHEAD)) &&
-			    (stcb->asoc.total_flight > 0)) { 
+			    (stcb->asoc.total_flight > 0)) {
 /*	&&		     sctp_is_feature_on(inp, SCTP_PCB_FLAGS_EXPLICIT_EOR))) {*/
 				break;
 			}
@@ -10837,7 +10845,7 @@ send_forward_tsn(struct sctp_tcb *stcb,
 	}
 	asoc->fwd_tsn_cnt++;
 	chk->copy_by_ref = 0;
-	/* 
+	/*
 	 * We don't do the old thing here since
 	 * this is used not for on-wire but to
 	 * tell if we are sending a fwd-tsn by
@@ -12145,6 +12153,11 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 		return;
 		break;
 	}
+	if (stcb->sctp_ep->plpmtud_supported && net->mtu_probing) {
+		hb->heartbeat.hb_info.probe_mtu = net->probe_mtu;
+	} else {
+		hb->heartbeat.hb_info.probe_mtu = 0;
+	}
 	net->hb_responded = 0;
 	TAILQ_INSERT_TAIL(&stcb->asoc.control_send_queue, chk, sctp_next);
 	stcb->asoc.ctrl_queue_cnt++;
@@ -12152,6 +12165,56 @@ sctp_send_hb(struct sctp_tcb *stcb, struct sctp_nets *net,int so_locked
 	return;
 }
 
+void sctp_send_pad(struct sctp_tcb *stcb, struct sctp_nets *net, uint16_t pad_size)
+{
+	struct sctp_tmit_chunk *chk;
+	struct sctp_pad_chunk *pad;
+
+	SCTP_TCB_LOCK_ASSERT(stcb);
+	KASSERT(pad_size >= 4, ("%s: padsize %u too small", __FUNCTION__, pad_size));
+	KASSERT(pad_size <= 2048, ("%s: padsize %u too large", __FUNCTION__, pad_size));
+	KASSERT(pad_size % 4 == 0, ("%s: padsize %u not aligned", __FUNCTION__, pad_size));
+	KASSERT(net->mtu_probing != 0, ("%s: mtu_probing not enabled", __FUNCTION__));
+	if (net == NULL) {
+		return;
+	}
+	sctp_alloc_a_chunk(stcb, chk);
+	if (chk == NULL) {
+		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Gak, can't get a chunk for pad\n");
+		return;
+	}
+	chk->copy_by_ref = 0;
+	chk->rec.chunk_id.id = SCTP_PAD_CHUNK;
+	chk->rec.chunk_id.can_take_data = 1;
+	chk->flags = 0;
+	chk->asoc = &stcb->asoc;
+
+	if (net->mtu_probing) {
+		chk->send_size = pad_size;
+	}
+	chk->data = sctp_get_mbuf_for_msg(chk->send_size, 0, M_NOWAIT, 1, MT_HEADER);
+	if (chk->data == NULL) {
+		/* no mbufs */
+		sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
+		return;
+	}
+	SCTP_BUF_LEN(chk->data) = chk->send_size;
+	chk->sent = SCTP_DATAGRAM_UNSENT;
+	chk->snd_count = 0;
+	chk->whoTo = net;
+	atomic_add_int(&chk->whoTo->ref_count, 1);
+	pad = mtod(chk->data, struct sctp_pad_chunk *);
+	memset(pad, 0, chk->send_size);
+	pad->ch.chunk_type = SCTP_PAD_CHUNK;
+	pad->ch.chunk_flags = 0;
+	pad->ch.chunk_length = htons(chk->send_size);
+	net->hb_responded = 0;
+	TAILQ_INSERT_TAIL(&stcb->asoc.control_send_queue, chk, sctp_next);
+	stcb->asoc.ctrl_queue_cnt++;
+	return;
+}
+
+
 void
 sctp_send_ecn_echo(struct sctp_tcb *stcb, struct sctp_nets *net,
 		   uint32_t high_tsn)
diff --git a/netinet/sctp_output.h b/netinet/sctp_output.h
index dfae447..8172f59 100755
--- a/netinet/sctp_output.h
+++ b/netinet/sctp_output.h
@@ -190,6 +190,8 @@ void sctp_send_sack(struct sctp_tcb *, int);
 
 void sctp_send_hb(struct sctp_tcb *, struct sctp_nets *, int);
 
+void sctp_send_pad(struct sctp_tcb *, struct sctp_nets *, uint16_t send_size);
+
 void sctp_send_ecn_echo(struct sctp_tcb *, struct sctp_nets *, uint32_t);
 
 
diff --git a/netinet/sctp_pcb.c b/netinet/sctp_pcb.c
index 9e9fca0..74e48d5 100755
--- a/netinet/sctp_pcb.c
+++ b/netinet/sctp_pcb.c
@@ -2832,6 +2832,7 @@ sctp_inpcb_alloc(struct socket *so, uint32_t vrf_id)
 	inp->reconfig_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_reconfig_enable);
 	inp->nrsack_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_nrsack_enable);
 	inp->pktdrop_supported = (uint8_t)SCTP_BASE_SYSCTL(sctp_pktdrop_enable);
+	inp->plpmtud_supported = (uint8_t) SCTP_BASE_SYSCTL(sctp_plpmtud_enable);
 	inp->idata_supported = 0;
 
 #if defined(__FreeBSD__)
@@ -4146,13 +4147,14 @@ sctp_inpcb_free(struct sctp_inpcb *inp, int immediate, int from)
 		SCTP_INP_INFO_WUNLOCK();
 		return;
 	}
+
 	if (SCTP_INP_LOCK_CONTENDED(inp))
 		being_refed++;
 	if (SCTP_INP_READ_CONTENDED(inp))
 		being_refed++;
 	if (SCTP_ASOC_CREATE_LOCK_CONTENDED(inp))
 		being_refed++;
-
+	
 	if ((inp->refcount) ||
 	    (being_refed) ||
 	    (inp->sctp_flags & SCTP_PCB_FLAGS_CLOSE_IP)) {
@@ -4595,6 +4597,11 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 	net->RTO_measured = 0;
 	stcb->asoc.numnets++;
 	net->ref_count = 1;
+	if (stcb->asoc.plpmtud_supported) {
+		net->probe_mtu = 0;
+		net->mtu_probing = 0;
+		net->probing_state = SCTP_PROBE_NONE;
+	}
 	net->cwr_window_tsn = net->last_cwr_tsn = stcb->asoc.sending_seq - 1;
 	net->port = port;
 	net->dscp = stcb->asoc.default_dscp;
@@ -4676,8 +4683,16 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 			if (rmtu == 0) {
 				/* Start things off to match mtu of interface please. */
 				SCTP_SET_MTU_OF_ROUTE(&net->ro._l_addr.sa,
-				                      net->ro.ro_rt, net->mtu);
+				    net->ro.ro_rt, net->mtu);
+			}  else {
+				if (stcb->asoc.plpmtud_supported) {
+					net->mtu = min(rmtu, SCTP_DEFAULT_MTU);
+				} else {
+					net->mtu = rmtu;
+				}
 			}
+			if (stcb->asoc.plpmtud_supported)
+				net->max_mtu = max(net->mtu, rmtu);
 		}
 	}
 #endif
@@ -4827,7 +4842,30 @@ sctp_add_remote_addr(struct sctp_tcb *stcb, struct sockaddr *newaddr,
 		TAILQ_REMOVE(&stcb->asoc.nets,
 			     stcb->asoc.primary_destination, sctp_next);
 		TAILQ_INSERT_HEAD(&stcb->asoc.nets,
-				  stcb->asoc.primary_destination, sctp_next);
+			    stcb->asoc.primary_destination, sctp_next);
+	}
+	if (stcb->asoc.plpmtud_supported) {
+		net->probing_state = SCTP_PROBE_NONE;
+		net->probe_mtu = 0;
+		/*if ((from == (SCTP_ALLOC_ASOC | SCTP_IN_COOKIE_PROC))
+		    || !(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {*/
+		if (from == SCTP_ADDR_DYNAMIC_ADDED) {
+			net->probing_state = SCTP_PROBE_BASE;
+#ifdef INET
+		if (newaddr->sa_family == AF_INET) {
+			net->probe_mtu = SCTP_PROBE_MTU_V4_BASE;
+		}
+#endif
+#ifdef INET6
+		if (newaddr->sa_family == AF_INET6) {
+			net->probe_mtu = SCTP_PROBE_MTU_V6_BASE;
+		}
+#endif
+		net->probed_mtu = SCTP_PROBE_MIN;
+		net->mtu_probing = 1;
+		net->probe_counts = 0;
+		sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+		}
 	}
 	return (0);
 }
diff --git a/netinet/sctp_pcb.h b/netinet/sctp_pcb.h
index b938625..911f286 100755
--- a/netinet/sctp_pcb.h
+++ b/netinet/sctp_pcb.h
@@ -501,6 +501,7 @@ struct sctp_inpcb {
 	uint8_t reconfig_supported;
 	uint8_t nrsack_supported;
 	uint8_t pktdrop_supported;
+	uint8_t plpmtud_supported;
 	struct sctp_nonpad_sndrcvinfo def_send;
 	/*-
 	 * These three are here for the sosend_dgram
diff --git a/netinet/sctp_peeloff.c b/netinet/sctp_peeloff.c
index 7c55aa3..7962a12 100755
--- a/netinet/sctp_peeloff.c
+++ b/netinet/sctp_peeloff.c
@@ -132,6 +132,7 @@ sctp_do_peeloff(struct socket *head, struct socket *so, sctp_assoc_t assoc_id)
 	n_inp->reconfig_supported = inp->reconfig_supported;
 	n_inp->nrsack_supported = inp->nrsack_supported;
 	n_inp->pktdrop_supported = inp->pktdrop_supported;
+	n_inp->plpmtud_supported = inp->plpmtud_supported;
 	n_inp->partial_delivery_point = inp->partial_delivery_point;
 	n_inp->sctp_context = inp->sctp_context;
 	n_inp->max_cwnd = inp->max_cwnd;
diff --git a/netinet/sctp_structs.h b/netinet/sctp_structs.h
index b5f3ef2..b66b704 100755
--- a/netinet/sctp_structs.h
+++ b/netinet/sctp_structs.h
@@ -442,6 +442,12 @@ struct sctp_nets {
 	uint32_t flowid;
 	uint8_t flowtype;
 #endif
+	uint32_t probe_mtu; /* actual mtu probing size */
+	uint32_t probed_mtu; /* mtu that has last been probed */
+	uint32_t max_mtu;
+	uint16_t probe_counts; /* Counter for the probing attempts */
+	uint16_t probing_state;
+	uint8_t mtu_probing; /* Flag to indicate whether mtu_probing should be processed */
 };
 
 
@@ -1244,6 +1250,7 @@ struct sctp_association {
 	uint8_t reconfig_supported;
 	uint8_t nrsack_supported;
 	uint8_t pktdrop_supported;
+	uint8_t plpmtud_supported;
 	uint8_t idata_supported;
 
 	/* Did the peer make the stream config (add out) request */
diff --git a/netinet/sctp_sysctl.c b/netinet/sctp_sysctl.c
index 1846475..4520a53 100755
--- a/netinet/sctp_sysctl.c
+++ b/netinet/sctp_sysctl.c
@@ -72,11 +72,7 @@ sctp_init_sysctls()
 	SCTP_BASE_SYSCTL(sctp_reconfig_enable) = SCTPCTL_RECONFIG_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_nrsack_enable) = SCTPCTL_NRSACK_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_pktdrop_enable) = SCTPCTL_PKTDROP_ENABLE_DEFAULT;
-#if !(defined(__FreeBSD__) && __FreeBSD_version >= 800000)
-#if !defined(SCTP_WITH_NO_CSUM)
-	SCTP_BASE_SYSCTL(sctp_no_csum_on_loopback) = SCTPCTL_LOOPBACK_NOCSUM_DEFAULT;
-#endif
-#endif
+	SCTP_BASE_SYSCTL(sctp_plpmtud_enable) = SCTPCTL_PLPMTUD_ENABLE_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_peer_chunk_oh) = SCTPCTL_PEER_CHKOH_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_max_burst_default) = SCTPCTL_MAXBURST_DEFAULT;
 	SCTP_BASE_SYSCTL(sctp_fr_max_burst_default) = SCTPCTL_FRMAXBURST_DEFAULT;
@@ -1220,6 +1216,7 @@ SYSCTL_PROC(_net_inet_sctp, OID_AUTO, asconf_enable, CTLFLAG_VNET|CTLTYPE_UINT|C
 SCTP_UINT_SYSCTL(reconfig_enable, sctp_reconfig_enable, SCTPCTL_RECONFIG_ENABLE)
 SCTP_UINT_SYSCTL(nrsack_enable, sctp_nrsack_enable, SCTPCTL_NRSACK_ENABLE)
 SCTP_UINT_SYSCTL(pktdrop_enable, sctp_pktdrop_enable, SCTPCTL_PKTDROP_ENABLE)
+SCTP_UINT_SYSCTL(plpmtud_enable, sctp_plpmtud_enable, SCTPCTL_PLPMTUD_ENABLE)
 #if defined(__APPLE__)
 #if !defined(SCTP_WITH_NO_CSUM)
 SCTP_UINT_SYSCTL(loopback_nocsum, sctp_no_csum_on_loopback, SCTPCTL_LOOPBACK_NOCSUM)
diff --git a/netinet/sctp_sysctl.h b/netinet/sctp_sysctl.h
index cbd29e3..2f48615 100755
--- a/netinet/sctp_sysctl.h
+++ b/netinet/sctp_sysctl.h
@@ -53,6 +53,7 @@ struct sctp_sysctl {
 	uint32_t sctp_reconfig_enable;
 	uint32_t sctp_nrsack_enable;
 	uint32_t sctp_pktdrop_enable;
+	uint32_t sctp_plpmtud_enable;
 	uint32_t sctp_fr_max_burst_default;
 #if !(defined(__FreeBSD__) && __FreeBSD_version >= 800000)
 #if !defined(SCTP_WITH_NO_CSUM)
@@ -216,6 +217,12 @@ struct sctp_sysctl {
 #define SCTPCTL_PKTDROP_ENABLE_MAX	1
 #define SCTPCTL_PKTDROP_ENABLE_DEFAULT	0
 
+/* plpmtud_enable: Enable Packetization Layer Path MTU Discovery */
+#define SCTPCTL_PLPMTUD_ENABLE_DESC	"Enable Packetization Layer PMTU Discovery"
+#define SCTPCTL_PLPMTUD_ENABLE_MIN	0
+#define SCTPCTL_PLPMTUD_ENABLE_MAX	1
+#define SCTPCTL_PLPMTUD_ENABLE_DEFAULT	0
+
 /* loopback_nocsum: Enable NO Csum on packets sent on loopback */
 #define SCTPCTL_LOOPBACK_NOCSUM_DESC	"Enable NO Csum on packets sent on loopback"
 #define SCTPCTL_LOOPBACK_NOCSUM_MIN	0
diff --git a/netinet/sctp_timer.c b/netinet/sctp_timer.c
index 9507c71..8fb04fa 100755
--- a/netinet/sctp_timer.c
+++ b/netinet/sctp_timer.c
@@ -1455,7 +1455,66 @@ sctp_heartbeat_timer(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 		} else {
 			ms_gone_by = 0xffffffff;
 		}
-		if ((ms_gone_by >= net->heart_beat_delay) ||
+
+		if (inp->plpmtud_supported && net->mtu_probing) {
+			uint32_t base = SCTP_PROBE_MTU_V4_BASE;
+			if ((++net->probe_counts < SCTP_PROBE_MAX_PROBES)
+			    && net->probing_state > SCTP_PROBE_ERROR
+			    && net->probing_state < SCTP_PROBE_DONE) {
+				sctp_send_a_probe(inp, stcb, net);
+			} else {
+				switch (net->probing_state) {
+				case SCTP_PROBE_BASE:
+					net->probe_counts = 0;
+					net->probed_mtu = SCTP_PROBE_MIN;
+					net->mtu_probing = 0;
+					net->probing_state = SCTP_PROBE_ERROR;
+					net->mtu = SCTP_PROBE_MIN;
+					sctp_pathmtu_adjustment(stcb, net->mtu);
+					sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+					break;
+				case SCTP_PROBE_SEARCH_UP:
+					net->probe_counts = 0;
+					net->mtu_probing = 0;
+					net->mtu = net->probed_mtu;
+					net->probing_state = SCTP_PROBE_DONE;
+					sctp_pathmtu_adjustment(stcb, net->mtu);
+					break;
+				case SCTP_PROBE_SEARCH_DOWN:
+					net->max_mtu = sctp_get_prev_mtu(net->max_mtu);
+#ifdef INET6
+					if (stcb->asoc.scope.ipv6_addr_legal) {
+						base = SCTP_PROBE_MTU_V6_BASE;
+					}
+#endif
+#ifdef INET
+					if (stcb->asoc.scope.ipv4_addr_legal) {
+						base = SCTP_PROBE_MTU_V4_BASE;
+					}
+#endif
+					if ((net->max_mtu > base) && (sctp_get_next_mtu(base) != net->max_mtu)) {
+						net->probe_mtu = sctp_get_next_mtu(base);
+						net->probe_counts = 0;
+						net->probing_state = SCTP_PROBE_SEARCH_UP;
+						sctp_send_a_probe(inp, stcb, net);
+					} else if (net->max_mtu == base) {
+						net->probe_mtu = base;
+						net->probe_counts = 0;
+						net->probing_state = SCTP_PROBE_BASE;
+						sctp_send_a_probe(inp, stcb, net);
+					} else if (net->max_mtu < base) {
+						net->probe_counts = 0;
+						net->probed_mtu = SCTP_PROBE_MIN;
+						net->mtu_probing = 0;
+						net->probing_state = SCTP_PROBE_ERROR;
+						net->mtu = SCTP_PROBE_MIN;
+						sctp_pathmtu_adjustment(stcb, net->mtu);
+						sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+					}
+					break;
+				}
+			}
+		} else if ((ms_gone_by >= net->heart_beat_delay) ||
 		    (net->dest_state & SCTP_ADDR_PF)) {
 			sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
 		}
@@ -1468,71 +1527,135 @@ sctp_pathmtu_timer(struct sctp_inpcb *inp,
     struct sctp_tcb *stcb,
     struct sctp_nets *net)
 {
-	uint32_t next_mtu, mtu;
-
-	next_mtu = sctp_get_next_mtu(net->mtu);
-
-	if ((next_mtu > net->mtu) && (net->port == 0)) {
-		if ((net->src_addr_selected == 0) ||
-		    (net->ro._s_addr == NULL) ||
-		    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
-			if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
-				sctp_free_ifa(net->ro._s_addr);
-				net->ro._s_addr = NULL;
-				net->src_addr_selected = 0;
-			} else  if (net->ro._s_addr == NULL) {
+	uint32_t next_mtu = 0, mtu = 0;
+
+	if (inp->plpmtud_supported) {
+		if (net->probing_state == SCTP_PROBE_DONE) {
+			net->mtu_probing = 1;
+			net->probe_mtu = net->mtu;
+			net->probing_state = SCTP_PROBE_BASE;
+			net->probe_counts = 0;
+			if ((net->src_addr_selected == 0) ||
+				(net->ro._s_addr == NULL) ||
+				(net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+				if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+					sctp_free_ifa(net->ro._s_addr);
+					net->ro._s_addr = NULL;
+					net->src_addr_selected = 0;
+				} else if (net->ro._s_addr == NULL) {
 #if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
-				if (net->ro._l_addr.sa.sa_family == AF_INET6) {
-					struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
-					/* KAME hack: embed scopeid */
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
 #if defined(__APPLE__)
 #if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)
-					(void)in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL);
+						in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL);
 #else
-					(void)in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL, NULL);
+						in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL, NULL);
 #endif
 #elif defined(SCTP_KAME)
-					(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
+						(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
 #else
-					(void)in6_embedscope(&sin6->sin6_addr, sin6);
+						in6_embedscope(&sin6->sin6_addr, sin6);
+#endif
+					}
 #endif
+net->ro._s_addr = sctp_source_address_selection(inp,
+						stcb,
+						(sctp_route_t *) & net->ro,
+						net, 0, stcb->asoc.vrf_id);
+#if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+#ifdef SCTP_KAME
+						(void)sa6_recoverscope(sin6);
+#else
+						(void)in6_recoverscope(sin6, &sin6->sin6_addr, NULL);
+#endif	/* SCTP_KAME */
+					}
+#endif				/* INET6 */
+				}
+				if (net->ro._s_addr)
+					net->src_addr_selected = 1;
+			}
+if (net->ro._s_addr) {
+				mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
+#if defined(INET) || defined(INET6)
+				if (net->port) {
+					mtu -= sizeof(struct udphdr);
 				}
 #endif
+				net->max_mtu = max(mtu, net->max_mtu);
+			}
+			sctp_send_a_probe(inp, stcb, net);
+		} else {
+			/* restart the timer */
+			sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
+		}
+	} else {
+		next_mtu = sctp_get_next_mtu(net->mtu);
+
+		if ((next_mtu > net->mtu) && (net->port == 0)) {
+			if ((net->src_addr_selected == 0) ||
+			    (net->ro._s_addr == NULL) ||
+			    (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+				if ((net->ro._s_addr != NULL) && (net->ro._s_addr->localifa_flags & SCTP_BEING_DELETED)) {
+					sctp_free_ifa(net->ro._s_addr);
+					net->ro._s_addr = NULL;
+					net->src_addr_selected = 0;
+				} else  if (net->ro._s_addr == NULL) {
+#if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+						/* KAME hack: embed scopeid */
+#if defined(__APPLE__)
+#if defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD)
+						(void)in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL);
+#else
+						(void)in6_embedscope(&sin6->sin6_addr, sin6, NULL, NULL, NULL);
+#endif
+#elif defined(SCTP_KAME)
+						(void)sa6_embedscope(sin6, MODULE_GLOBAL(ip6_use_defzone));
+#else
+						(void)in6_embedscope(&sin6->sin6_addr, sin6);
+#endif
+					}
+#endif
 
-				net->ro._s_addr = sctp_source_address_selection(inp,
-										stcb,
-										(sctp_route_t *)&net->ro,
-										net, 0, stcb->asoc.vrf_id);
+					net->ro._s_addr = sctp_source_address_selection(inp,
+											stcb,
+											(sctp_route_t *)&net->ro,
+											net, 0, stcb->asoc.vrf_id);
 #if defined(INET6) && defined(SCTP_EMBEDDED_V6_SCOPE)
-				if (net->ro._l_addr.sa.sa_family == AF_INET6) {
-					struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
+					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
+						struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&net->ro._l_addr;
 #ifdef SCTP_KAME
-					(void)sa6_recoverscope(sin6);
+						(void)sa6_recoverscope(sin6);
 #else
-					(void)in6_recoverscope(sin6, &sin6->sin6_addr, NULL);
+						(void)in6_recoverscope(sin6, &sin6->sin6_addr, NULL);
 #endif	/* SCTP_KAME */
-				}
+					}
 #endif	/* INET6 */
+				}
+				if (net->ro._s_addr)
+					net->src_addr_selected = 1;
 			}
-			if (net->ro._s_addr)
-				net->src_addr_selected = 1;
-		}
-		if (net->ro._s_addr) {
-			mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
+			if (net->ro._s_addr) {
+				mtu = SCTP_GATHER_MTU_FROM_ROUTE(net->ro._s_addr, &net->ro._s_addr.sa, net->ro.ro_rt);
 #if defined(INET) || defined(INET6)
-			if (net->port) {
-				mtu -= sizeof(struct udphdr);
-			}
+				if (net->port) {
+					mtu -= sizeof(struct udphdr);
+				}
 #endif
-			if (mtu > next_mtu) {
-				net->mtu = next_mtu;
-			} else {
-				net->mtu = mtu;
+				if (mtu > next_mtu) {
+					net->mtu = next_mtu;
+				} else {
+					net->mtu = mtu;
+				}
 			}
 		}
+		/* restart the timer */
+		sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 	}
-	/* restart the timer */
-	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 }
 
 void
diff --git a/netinet/sctp_usrreq.c b/netinet/sctp_usrreq.c
index 619eee5..fc7ad3c 100755
--- a/netinet/sctp_usrreq.c
+++ b/netinet/sctp_usrreq.c
@@ -305,7 +305,7 @@ sctp_notify(struct sctp_inpcb *inp,
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 	struct socket *so;
 #endif
-	int timer_stopped;
+	int timer_stopped = 0;
 
 	if (icmp_type != ICMP_UNREACH) {
 		/* We only care about unreachable */
@@ -349,13 +349,165 @@ sctp_notify(struct sctp_inpcb *inp,
 		atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 		(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_2);
+		                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_1);
 #if defined(__APPLE__) || defined(SCTP_SO_LOCK_TESTING)
 		SCTP_SOCKET_UNLOCK(so, 1);
 		/* SCTP_TCB_UNLOCK(stcb); MT: I think this is not needed.*/
 #endif
 		/* no need to unlock here, since the TCB is gone */
 	} else if (icmp_code == ICMP_UNREACH_NEEDFRAG) {
+		/* Stop the PMTU timer. */
+		if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+			timer_stopped = 1;
+			sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
+			    SCTP_FROM_SCTP_USRREQ + SCTP_LOC_2);
+		}
+	}
+	/* Adjust destination size limit */
+	if (inp->plpmtud_supported) {
+		uint32_t base;
+#ifdef INET6
+		if (stcb->asoc.scope.ipv6_addr_legal) {
+			base = SCTP_PROBE_MTU_V6_BASE;
+		}
+#endif
+#ifdef INET
+		if (stcb->asoc.scope.ipv4_addr_legal) {
+			base = SCTP_PROBE_MTU_V4_BASE;
+		}
+#endif
+		net->probe_counts = 0;
+		if (net->probing_state == SCTP_PROBE_DONE) {
+			sctp_pathmtu_timer(inp, stcb, net);
+		}
+		if (net->probing_state > SCTP_PROBE_NONE && net->probing_state < SCTP_PROBE_DONE) {
+		if (next_mtu == 0) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu_probing = 0;
+				net->mtu = net->probed_mtu;
+				net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_3);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+				if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_4);
+				}
+				sctp_pathmtu_adjustment(stcb, net->mtu);
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->max_mtu = sctp_get_prev_mtu(net->max_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			}
+		} else if (net->probed_mtu <= next_mtu && next_mtu < net->probe_mtu) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu_probing = 0;
+				net->mtu = net->probed_mtu;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probe_mtu = net->max_mtu;
+				net->probe_counts = 0;
+				sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				break;
+			}
+		} else if (next_mtu < net->probed_mtu) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				if (next_mtu < base) {
+					net->probed_mtu = SCTP_PROBE_MIN;
+					net->mtu_probing = 0;
+					net->max_mtu = min(net->max_mtu, next_mtu);
+					net->probing_state = SCTP_PROBE_ERROR;
+					sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				} else {
+					net->probe_mtu = base;
+					net->probed_mtu = base;
+					net->mtu = min(net->probed_mtu, next_mtu);
+					net->max_mtu = min(net->max_mtu, next_mtu);
+					net->probing_state = SCTP_PROBE_BASE;
+					net->probe_counts = 0;
+					sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				}
+				break;
+			}
+		} else if (next_mtu == base) {
+			switch (net->probing_state) {
+			case SCTP_PROBE_BASE:
+				net->probed_mtu = SCTP_PROBE_MIN;
+				net->mtu_probing = 0;
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				net->probing_state = SCTP_PROBE_ERROR;
+				sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+				break;
+			case SCTP_PROBE_SEARCH_DOWN:
+				net->mtu_probing = 0;
+				net->mtu = next_mtu;
+				net->probed_mtu = next_mtu;
+				net->max_mtu = next_mtu;
+				net->probing_state = SCTP_PROBE_DONE;
+				sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_5);
+				sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+				if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+					sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_6);
+				}
+				sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				break;
+			case SCTP_PROBE_SEARCH_UP:
+				net->mtu = min(net->probed_mtu, next_mtu);
+				net->max_mtu = min(net->max_mtu, next_mtu);
+				if (net->probed_mtu > base) {
+					net->probe_mtu = base;
+					net->probing_state = SCTP_PROBE_BASE;
+					net->probe_counts = 0;
+					sctp_send_a_probe(stcb->sctp_ep, stcb, net);
+				} else {
+					net->probing_state = SCTP_PROBE_DONE;
+					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTP_USRREQ + SCTP_LOC_7);
+					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+					if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net,
+						SCTP_FROM_SCTP_USRREQ + SCTP_LOC_8);
+					}
+					sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+				}
+				break;
+			}
+		}
+		SCTP_TCB_UNLOCK(stcb);
+	}
+	else {
 		/* Find the next (smaller) MTU */
 		if (next_mtu == 0) {
 			/*
@@ -366,14 +518,7 @@ sctp_notify(struct sctp_inpcb *inp,
 			 */
 			next_mtu = sctp_get_prev_mtu(ip_len);
 		}
-		/* Stop the PMTU timer. */
-		if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
-			timer_stopped = 1;
-			sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-			                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_1);
-		} else {
-			timer_stopped = 0;
-		}
+
 		/* Update the path MTU. */
 		if (net->port) {
 			next_mtu -= sizeof(struct udphdr);
@@ -397,8 +542,7 @@ sctp_notify(struct sctp_inpcb *inp,
 			sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 		}
 		SCTP_TCB_UNLOCK(stcb);
-	} else {
-		SCTP_TCB_UNLOCK(stcb);
+		}
 	}
 }
 #endif
@@ -1155,7 +1299,7 @@ sctp_disconnect(struct socket *so)
 					SCTP_STAT_DECR_GAUGE32(sctps_currestab);
 				}
 				(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-				                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_3);
+				                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_9);
 				/* No unlock tcb assoc is gone */
 				return (0);
 			}
@@ -1220,7 +1364,7 @@ sctp_disconnect(struct socket *so)
 					struct mbuf *op_err;
 				abort_anyway:
 					op_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, "");
-					stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_4;
+					stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_10;
 					sctp_send_abort_tcb(stcb, op_err, SCTP_SO_LOCKED);
 					SCTP_STAT_INCR_COUNTER32(sctps_aborted);
 					if ((SCTP_GET_STATE(&stcb->asoc) == SCTP_STATE_OPEN) ||
@@ -1229,7 +1373,7 @@ sctp_disconnect(struct socket *so)
 					}
 					SCTP_INP_RUNLOCK(inp);
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-					                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_5);
+					                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_11);
 					return (0);
 				} else {
 					sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_CLOSING, SCTP_SO_LOCKED);
@@ -1405,7 +1549,7 @@ sctp_shutdown(struct socket *so)
 				struct mbuf *op_err;
 			abort_anyway:
 				op_err = sctp_generate_cause(SCTP_CAUSE_USER_INITIATED_ABT, "");
-				stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_6;
+				stcb->sctp_ep->last_abort_code = SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12;
 				sctp_abort_an_association(stcb->sctp_ep, stcb,
 							  op_err, SCTP_SO_LOCKED);
 				SCTP_INP_RUNLOCK(inp);
@@ -2074,7 +2218,7 @@ sctp_do_connect_x(struct socket *so, struct sctp_inpcb *inp, void *optval,
 	/* Fill in the return id */
 	if (error) {
 		(void)sctp_free_assoc(inp, stcb, SCTP_PCBFREE_FORCE,
-		                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_7);
+		                      SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
 		goto out_now;
 	}
 	a_id = (sctp_assoc_t *)optval;
@@ -5673,7 +5817,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 			(void)SCTP_GETTIME_TIMEVAL(&stcb->asoc.time_entered);
 			sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp, stcb,
 					stcb->asoc.primary_destination,
-					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_8);
+					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_14);
 			sctp_send_initiate(inp, stcb, SCTP_SO_LOCKED);
 		} else {
 			/*
@@ -6091,7 +6235,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
 					    !(net->dest_state & SCTP_ADDR_NOHB)) {
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_9);
+								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_15);
 					}
 					net->dest_state |= SCTP_ADDR_NOHB;
 				}
@@ -6102,7 +6246,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						net->heart_beat_delay = 0;
 					}
 					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-					                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_10);
+					                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_16);
 					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 					net->dest_state &= ~SCTP_ADDR_NOHB;
 				}
@@ -6115,7 +6259,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				if ((paddrp->spp_flags & SPP_PMTUD_DISABLE) && (paddrp->spp_pathmtu >= SCTP_SMALLEST_PMTU)) {
 					if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_11);
+								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
 					}
 					net->dest_state |= SCTP_ADDR_NO_PMTUD;
 					net->mtu = paddrp->spp_pathmtu;
@@ -6155,7 +6299,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 							                stcb->sctp_ep, stcb, net,
-							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12);
+							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
 					}
@@ -6200,7 +6344,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								                stcb->sctp_ep, stcb, net,
-								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
+								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_19);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
 						}
@@ -6236,7 +6380,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							net->dest_state &= ~SCTP_ADDR_NOHB;
 						}
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
-								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_14);
+								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_20);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 					}
 					sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
@@ -6248,7 +6392,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								                inp, stcb, net,
-								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_15);
+								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_21);
 							}
 						}
 					}
@@ -6258,7 +6402,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 							sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
-									SCTP_FROM_SCTP_USRREQ + SCTP_LOC_16);
+									SCTP_FROM_SCTP_USRREQ + SCTP_LOC_22);
 						}
 						net->dest_state |= SCTP_ADDR_NO_PMTUD;
 						net->mtu = paddrp->spp_pathmtu;
@@ -7201,7 +7345,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 						sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 						                stcb->sctp_ep, stcb, net,
-						                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
+						                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_23);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 					}
 				}
@@ -7232,7 +7376,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 							                stcb->sctp_ep, stcb, net,
-							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
+							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_24);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
 					}
@@ -8536,7 +8680,7 @@ sctp_accept(struct socket *so, struct mbuf *nam)
 	if (stcb->asoc.state & SCTP_STATE_ABOUT_TO_BE_FREED) {
 		SCTP_TCB_LOCK(stcb);
 		sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
-		                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_19);
+		                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_25);
 	}
 	return (0);
 }
diff --git a/netinet/sctputil.c b/netinet/sctputil.c
index 88cc6d4..4054616 100755
--- a/netinet/sctputil.c
+++ b/netinet/sctputil.c
@@ -839,7 +839,7 @@ static uint32_t sctp_mtu_sizes[] = {
 	1492,
 	1500,
 	1536,
-	2002,
+	2000,
 	2048,
 	4352,
 	4464,
@@ -866,7 +866,7 @@ sctp_get_prev_mtu(uint32_t val)
 			break;
 		}
 	}
-	return (sctp_mtu_sizes[i - 1]);
+	return (sctp_mtu_sizes[i - 1] - sctp_mtu_sizes[i - 1] % 4);
 }
 
 /*
@@ -880,8 +880,8 @@ sctp_get_next_mtu(uint32_t val)
 	uint32_t i;
 
 	for (i = 0; i < (sizeof(sctp_mtu_sizes) / sizeof(uint32_t)); i++) {
-		if (val < sctp_mtu_sizes[i]) {
-			return (sctp_mtu_sizes[i]);
+		if (val < sctp_mtu_sizes[i] - sctp_mtu_sizes[i] % 4) {
+			return (sctp_mtu_sizes[i] - sctp_mtu_sizes[i] % 4);
 		}
 	}
 	return (val);
@@ -1046,6 +1046,7 @@ sctp_init_asoc(struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 	asoc->reconfig_supported = inp->reconfig_supported;
 	asoc->nrsack_supported = inp->nrsack_supported;
 	asoc->pktdrop_supported = inp->pktdrop_supported;
+	asoc->plpmtud_supported = inp->plpmtud_supported;
 	asoc->idata_supported = inp->idata_supported;
 	asoc->sctp_cmt_pf = (uint8_t)0;
 	asoc->sctp_frag_point = inp->sctp_frag_point;
@@ -2178,7 +2179,8 @@ sctp_timer_start(int t_type, struct sctp_inpcb *inp, struct sctp_tcb *stcb,
 				to_ticks = to_ticks - jitter;
 			}
 			if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
-			    !(net->dest_state & SCTP_ADDR_PF)) {
+			    !(net->dest_state & SCTP_ADDR_PF) &&
+			    !(net->mtu_probing)) {
 				to_ticks += net->heart_beat_delay;
 			}
 			/*
@@ -8261,3 +8263,50 @@ sctp_hc_get_mtu(union sctp_sockstore *addr, uint16_t fibnum)
 	return ((uint32_t)tcp_hc_getmtu(&inc));
 }
 #endif
+
+void
+sctp_send_a_probe(struct sctp_inpcb *inp,
+    struct sctp_tcb *stcb,
+    struct sctp_nets *net)
+{
+	int ovh, sum_probe_chunks;
+	uint16_t send_size;
+
+	if (!net->mtu_probing && net->probing_state > SCTP_PROBE_NONE) {
+		net->mtu_probing = 1;
+		net->probe_counts = 0;
+	}
+	if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {
+		ovh = SCTP_MIN_OVERHEAD;
+	} else {
+		ovh = SCTP_MIN_V4_OVERHEAD;
+	}
+#if defined(__FreeBSD__)
+#if defined(INET) || defined(INET6)
+	if (net->port) {
+		net->probe_mtu -= sizeof(struct udphdr);
+	}
+#endif
+#endif
+	sctp_send_hb(stcb, net, SCTP_SO_NOT_LOCKED);
+	sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net, SCTP_FROM_SCTPUTIL + SCTP_LOC_11);
+	sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
+	if (net->probe_mtu > 0) {
+		sum_probe_chunks = net->probe_mtu - ovh - sizeof(struct sctp_heartbeat_info_param) - sizeof(struct sctp_chunkhdr);
+		while (sum_probe_chunks > 0) {
+			if (sum_probe_chunks > 2048) {
+				send_size = 2048;
+			} else {
+				send_size = sum_probe_chunks;
+			}
+			sctp_send_pad(stcb, net, send_size);
+			sum_probe_chunks -= send_size;
+		}
+	}
+	sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_HB_TMR, SCTP_SO_NOT_LOCKED);
+	if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
+		sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
+		    SCTP_FROM_SCTPUTIL + SCTP_LOC_12);
+	}
+	sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, stcb->sctp_ep, stcb, net);
+}
diff --git a/netinet/sctputil.h b/netinet/sctputil.h
index 59dd364..548af75 100755
--- a/netinet/sctputil.h
+++ b/netinet/sctputil.h
@@ -273,6 +273,9 @@ int sctp_cmpaddr(struct sockaddr *, struct sockaddr *);
 
 void sctp_print_address(struct sockaddr *);
 
+void
+sctp_send_a_probe(struct sctp_inpcb *inp, struct sctp_tcb *stcb, struct sctp_nets *net);
+
 int
 sctp_release_pr_sctp_chunk(struct sctp_tcb *, struct sctp_tmit_chunk *,
     uint8_t, int
